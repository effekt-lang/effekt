// A core or machine `jump` instruction has to be desugared into the
// LLVM instructions `tail call ; ret void`, since LLVM does **not** know of the
// concept of a global jump and the precious C stack should not be strained.

// A frame is one function's environment (serializable with exceptions)
// together with its static behaviour.
// The static `@scanner` function pointer knows about the frame's type and layout
// and can therefore both copy and destroy the frame (given its dynamically known
// absolute reference position on the heap).
// The layout is a bit more complex since ADTs were added.
// frame:
//     @scanner
//     primitive_1
//     primitive_2
//     ...
//     primitive_n
//     boxed_1
//     boxed_2
//     ...
//     boxed_n

// From a function's point of view, its stacks form an array-singly-linked-list-
// hybrid data structure (a "metastack" of sorts) which defines the entire
// environment known to it.
// When no effect arbitration is necessary, a subfunction simply gets its frame
// pushed onto the heap relative to the stack's `top`.
// If an effect split happens, a new stack is created with evidence-sufficiently
// deep parent copying.
// A stack is copiable and destructible to varying depths (the necessary depth is
// called evidence) only utilizing the various frames' `@scanner` implementations.
// [jfrech, 2022-07-12] TODO apparently, this notion is subtly incorrect, yet its clarification requires exact specification of what we mean by an *environment* (local register representation of a frame, C-style environment, or Effekt-stack baked state representation)
// Thus, there are multiple interpretations of the term "environment":
// * C environment: state which hangs inside registers
// * Effekt environment: frozen state which can be swapped in and out of the
//   C environment
// * Clojure environment: A clojure's history of gobbled data.

