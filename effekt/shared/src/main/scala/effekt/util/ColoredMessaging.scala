package effekt
package util

import effekt.symbols.{ LocalName, Name, NoName, QualifiedName }
import effekt.util.messages.*
import kiama.util.{ Messaging, Position, Positions, Severities }
import kiama.util.Severities._

trait ColoredMessaging extends EffektMessaging {

  // Colors
  // ------

  def yellow(s: String): String
  def red(s: String): String
  def white(s: String): String
  def bold(s: String): String
  def bold_red(s: String): String
  def highlight(s: String): String
  def underlined(s: String): String

  def indent(s: String): String = s.linesIterator.map(l => "  " + l).mkString("\n")

  def severityToWord(severity: Severity): String =
    severity match {
      case Error       => red("error")
      case Warning     => yellow("warning")
      case Information => white("info")
      case Hint        => "hint"
    }

  override def formatMessage(message: EffektError): String =
    (message.startPosition, message.finishPosition) match {
      case (Some(from), Some(to)) if from.line == to.line => formatMessage(message, from, to)
      case (Some(from), _) => formatMessage(message, from)
      case (None, _) =>
        val severity = severityToWord(message.severity)
        s"[$severity] ${formatContent(message)}\n"
    }

  def formatMessage(message: EffektError, from: Position): String = {
    val severity = severityToWord(message.severity)
    val context = util.AnsiHighlight(from.optContext.getOrElse(""))
    s"[$severity] ${homogenizePath(from.format)} ${formatContent(message)}\n$context\n"
  }

  def formatMessage(message: EffektError, from: Position, to: Position): String = {
    val severity = severityToWord(message.severity)
    val context = util.AnsiHighlight(from.source.optLineContents(from.line).map { src =>
      src + "\n" + (" " * (from.column - 1)) + ("^" * (to.column - from.column))
    }.getOrElse(""))
    s"[$severity] ${homogenizePath(from.format)} ${formatContent(message)}\n$context\n"
  }

  // Filter out duplicates
  // TODO this is a hack and should be solved in typer, where the messages are generated by unification
  override def formatMessages(messages: Messages): String =
    messages.sorted.map(formatMessage).distinct.mkString("")

  override def formatContent(err: EffektError): String = err match {
    case ParseError(msg, range)               => msg
    case PlainTextError(msg, range, severity) => msg
    case StructuredError(StructuredMessage(sc, args), _, _) => sc.s(args.map {
      case name: Name          => highlight(name.name)
      case n: Int              => highlight(n.toString)
      case nested: EffektError => formatContent(nested)
      case other               => other.toString
    }: _*)
  }

  def fullname(n: Name): String = n match {
    case n: QualifiedName => n.qualifiedName
    case n: Name          => n.name
  }
}

class PlainMessaging extends ColoredMessaging {
  def yellow(s: String): String = s
  def red(s: String): String = s
  def white(s: String): String = s
  def bold(s: String): String = s
  def bold_red(s: String): String = s
  def highlight(s: String): String = s
  def underlined(s: String): String = s

  // Don't show context in plain messaging.
  override def formatMessage(message: EffektError, from: Position): String = {
    val severity = severityToWord(message.severity)
    s"[$severity] ${homogenizePath(from.format)} ${formatContent(message)}\n"
  }

  override def formatMessage(message: EffektError, from: Position, to: Position): String =
    formatMessage(message, from)
}

class AnsiColoredMessaging extends ColoredMessaging {
  def yellow(s: String): String = Console.YELLOW + s + Console.RESET
  def red(s: String): String = Console.RED + s + Console.RESET
  def white(s: String): String = Console.WHITE + s + Console.RESET
  def bold(s: String): String = Console.BOLD + s + Console.RESET
  def bold_red(s: String): String = Console.BLACK + Console.RED_B + s + Console.RESET
  def highlight(s: String): String = Console.BLACK + Console.WHITE_B + s + Console.RESET
  def underlined(s: String): String = Console.UNDERLINED + s + Console.RESET
}

