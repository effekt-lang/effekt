import examples/benchmarks/runner

def tail[A](ls: List[A]): List[A] =
  ls match {
    case Nil() => panic("Empty List")
    case Cons(_, as) => as
  }

def head[A](ls: List[A]): A =
  ls match {
    case Nil() => panic("Empty List")
    case Cons(a, _) => a
  }

def len_i_loop(l: List[Int], acc: Int): Int =
  l match {
    case Nil() => acc
    case Cons(hd, tl) => len_i_loop(tl, acc + 1)
  }

def len_i(l: List[Int]): Int = len_i_loop(l, 0)


def loop_p(j: Int, perms: List[List[Int]], x: List[Int], n: Int): (List[List[Int]], List[Int]) = {
  if (j == 0) {
    p(n - 1, perms, x)
  } else {
    val (perms, x) = p(n - 1, perms, x)
    val (perms, x) = f(n, perms, x)
    loop_p(j - 1, perms, x, n)
  }
}

def p(n: Int, perms: List[List[Int]], x: List[Int]): (List[List[Int]], List[Int]) =
  if (1 < n) {
    loop_p(n - 1, perms, x, n)
  } else {
    (perms, x)
  }

def f(n: Int, perms: List[List[Int]], x: List[Int]): (List[List[Int]], List[Int]) = {
  val x = rev_loop(x, n, list_tail(x, n))
  val perms = Cons(x, perms)
  (perms, x)
}

def rev_loop(x: List[Int], n: Int, y: List[Int]): List[Int] =
  if (n == 0) {
    y
  } else {
    rev_loop(tail(x), n - 1, Cons(head(x), y))
  }

def list_tail[A](x: List[A], n: Int): List[A] =
  if (n == 0) {
    x
  } else {
    list_tail(tail(x), n - 1)
  }

def permutations(x0: List[Int]): List[List[Int]] = {
  val (final_perms, x) = p(len_i(x0), Cons(x0, Nil()), x0)
  final_perms
}

def loop_sum(y: List[Int]): Int =
  y match {
    case Nil() => 0
    case Cons(i, is_) => i + loop_sum(is_)
  }

def sumlists(x: List[List[Int]]): Int =
  x match {
    case Nil() => 0
    case Cons(is_, iss) => loop_sum(is_) + sumlists(iss)
  }

def loop_one2n(n: Int, p: List[Int]): List[Int] =
  if (n == 0) {
    p
  } else {
    loop_one2n(n - 1, Cons(n, p))
  }

def one2n(n: Int): List[Int] =
  loop_one2n(n, Nil())

def factorial(n: Int): Int =
  if (n == 1) {
    1
  } else {
    n * factorial(n - 1)
  }

def loop_work(m: Int, perms: List[List[Int]]): List[List[Int]] =
  if (m == 0) {
    perms
  } else {
    loop_work(m - 1, permutations(head(perms)))
  }

def run_benchmark { work: () => List[List[Int]] } { result: List[List[Int]] => Bool }: Bool =
  result(work())

def perm9(m: Int, n: Int): Bool =
  run_benchmark { loop_work(m, permutations(one2n(n))) } { result =>
    sumlists(result) == (((n * (n + 1)) * factorial(n)) / 2)
  }

def run(m: Int): Int = {
  // only one argument
  val n = m * 3
  if (perm9(m, n)) { 1 } else { 0 }
}

def main() = benchmark(2){run}