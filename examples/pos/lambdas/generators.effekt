effect Yield(n: Int): Unit

type Result {
  Next(n: Int);
  Done()
}

def numbers() = {
  do Yield(1);
  do Yield(2);
  do Yield(3)
}

def main() = {

  var generator: () => Result at {main} = fun() { Done() }

  try {
    numbers()
    generator = fun() { Done() }
  } with Yield { n =>
    generator = fun() { resume(()); Next(n) }
  }

  // right now we do not infer unbox for a mutable variable since it
  // already is of block type.
  def gen() = (unbox generator)()
  println(gen())
  println(gen())
  println(gen())
  println(gen())
  println(gen())
}