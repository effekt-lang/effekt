module immutable/dequeue

import immutable/list
import immutable/option

// An implementation of a functional dequeue, using Okasaki's
// bankers dequeue implementation.
//
// Translation from the Haskell implementation:
//   https://hackage.haskell.org/package/dequeue-0.1.12/docs/src/Data-Dequeue.html#Dequeue
record Dequeue[R](front: List[R], frontSize: Int, rear: List[R], rearSize: Int)

def emptyQueue[R](): Dequeue[R] = Dequeue(Nil(), 0, Nil(), 0)

def isEmpty[R](dq: Dequeue[R]): Boolean = dq match {
    case Dequeue(f, fs, r, rs) => (fs == 0) && (rs == 0)
}

def size[R](dq: Dequeue[R]): Int = dq match {
    case Dequeue(f, fs, r, rs) => fs + rs
}

def first[R](dq: Dequeue[R]): Option[R] = dq match {
    case Dequeue(f, fs, r, rs) =>
      if ((fs == 0) && (rs == 1)) { r.headOption }
      else { f.headOption }
}

def last[R](dq: Dequeue[R]): Option[R] = dq match {
    case Dequeue(f, fs, r, rs) =>
      if ((fs == 1) && (rs == 0)) { f.headOption }
      else { r.headOption }
}

def check[R](dq: Dequeue[R]): Dequeue[R] = dq match {
    case Dequeue(f, fs, r, rs) => {
        val c = 4;
        val size1 = (fs + rs) / 2;
        val size2 = (fs + rs) - size1;

        if (fs > c * rs + 1) {
            val front = f.take(size1);
            val rear = r.append(f.drop(size1).reverse);
            Dequeue(front, size1, rear, size2)
        } else if (rs > c * fs + 1) {
            val front = f.append(r.drop(size1).reverse);
            val rear = r.take(size1);
            Dequeue(front, size2, rear, size1)
        } else {
            dq
        }
    }
}

def pushFront[R](dq: Dequeue[R])(el: R): Dequeue[R] = dq match {
    case Dequeue(f, fs, r, rs) => Dequeue(Cons(el, f), fs + 1, r, rs).check
}

def popFront[R](dq: Dequeue[R]): Option[(R, Dequeue[R])] = dq match {
    case Dequeue(f, fs, r, rs) =>
        if ((fs == 0) && (rs == 1)) r.headOption.map { x => (x, emptyQueue()) }
        else f match {
            case Nil() => None()
            case Cons(x, rest) => Some((x, Dequeue(rest, fs - 1, r, rs).check))
        }
}

def pushBack[R](dq: Dequeue[R])(el: R): Dequeue[R] = dq match {
    case Dequeue(f, fs, r, rs) => Dequeue(f, fs, Cons(el, r), rs + 1).check
}

def popBack[R](dq: Dequeue[R]): Option[(R, Dequeue[R])] = dq match {
    case Dequeue(f, fs, r, rs) =>
        if ((fs == 1) && (rs == 0)) f.headOption.map { x => (x, emptyQueue()) }
        else r match {
            case Nil() => None()
            case Cons(x, rest) => Some((x, Dequeue(f, fs, rest, rs - 1).check))
        }
}
