module immutable/cslist

import list
import array

// a chez scheme cons list
extern type CSList[A]
extern def cons[A](el: A, rest: CSList[A]) at pure: CSList[A] =
  chez "(cons ${el} ${rest})"

extern def nil[A]() at pure: CSList[A] =
  chez "(list)"

extern def isEmpty[A](l: CSList[A]) at pure: Bool =
  chez "(null? ${l})"

// unsafe!
extern def head[A](l: CSList[A]) at pure: A =
  chez "(car ${l})"

// unsafe!
extern def tail[A](l: CSList[A]) at pure: CSList[A] =
  chez "(cdr ${l})"


def toChez[A](l: List[A]): CSList[A] = l match {
  case Nil() => nil()
  case Cons(a, rest) => cons(a, rest.toChez)
}

def fromChez[A](l: CSList[A]): List[A] =
  if (l.isEmpty) Nil() else Cons(l.head, l.tail.fromChez)

// Old From Chez
// -------------
extern def toArray[A](l: CSList[A]) at pure: Array[A] =
  chez "(list->vector ${l})"
