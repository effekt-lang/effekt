module args

extern def commandLineArgs() at io: List[String] =
  js { js::commandLineArgs() }
  chez { chez::commandLineArgs() }
  llvm { llvm::commandLineArgs() }
  vm { Nil() }

namespace js {
  extern type Args // = Array[String]

  extern def nativeArgs() at io: Args = js "process.argv.slice(1)"

  extern def argCount(args: Args) at io: Int = js "${args}.length"

  extern def argument(args: Args, i: Int) at io: String = js "${args}[${i}]"

  def commandLineArgs(): List[String] = {
    def toList(args: Args, start: Int, acc: List[String]): List[String] =
      if (start < 1) { acc }
      else args.toList(start - 1, Cons(args.argument(start), acc))

    val args = nativeArgs()
    args.toList(args.argCount - 1, Nil())
  }
}

namespace chez {
  extern type Args // = CSList[String]

  extern def nativeArgs() at io: Args =
    chez "(cdr (command-line))"

  extern def isEmpty(l: Args) at {}: Bool =
    chez "(null? ${l})"

  extern def head(l: Args) at {}: String =
    chez "(car ${l})"

  extern def tail(l: Args) at {}: Args =
    chez "(cdr ${l})"

  def toList(l: Args): List[String] =
    if (l.isEmpty) Nil() else Cons(l.head, l.tail.toList)

  def commandLineArgs(): List[String] = nativeArgs().toList
}

namespace llvm {
  extern def argCount() at io: Int =
    llvm """
      %c = call %Int @c_get_argc()
      ret %Int %c
    """

  extern def argument(i: Int) at io: String =
    llvm """
      %s = call %Pos @c_get_arg(%Int ${i})
      ret %Pos %s
    """

  def commandLineArgs(): List[String] = {
    def toList(start: Int, acc: List[String]): List[String] =
      if (start < 1) { acc }
      else toList(start - 1, Cons(argument(start), acc))

    toList(argCount() - 1, Nil())
  }
}
