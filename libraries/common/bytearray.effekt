module bytearray

import effekt
import stream
import control

/**
 * A memory managed, mutable, fixed-length array of bytes.
 *
 * We represent bytearrays like positive types.
 *
 *  - The field `tag` contains the size
 *  - The field `obj` points to memory with the following layout:
 *
 *       +--[ Header ]--+--------------+
 *       | Rc  | Eraser | Contents ... |
 *       +--------------+--------------+
 *
 * The eraser does nothing.
 */
extern type ByteArray
  // = llvm "%Pos"
  // = js "Uint8Array"
  // = chez "bytevector"

/// Allocates a new bytearray with the given `size`, its values are zero bytes.
extern def allocate(size: Int) at global: ByteArray =
  js "(new Uint8Array(${size}))"
  llvm """
    %object_size = add i64 ${size}, 16
    %object_alloc = tail call noalias ptr @calloc(i64 %object_size, i64 1)
    store i64 0, ptr %object_alloc, align 8
    %object_data_ptr = getelementptr inbounds i8, ptr %object_alloc, i64 8
    store ptr @bytearray_erase_noop, ptr %object_data_ptr, align 8
    %ret_object1 = insertvalue %Pos poison, i64 ${size}, 0
    %ret_object2 = insertvalue %Pos %ret_object1, ptr %object_alloc, 1
    ret %Pos %ret_object2
  """
  chez "(make-bytevector ${size})"
  vm "bytearray::allocate(Int)"

extern def size(arr: ByteArray) at {}: Int =
  js "${arr}.length"
  llvm """
    %size = extractvalue %Pos ${arr}, 0
    tail call void @erasePositive(%Pos ${arr})
    ret i64 %size
  """
  chez "(bytevector-length ${arr})"
  vm "bytearray::size(ByteArray)"

extern js """
  function bytearray$get(arr, index) {
    if (index < 0 || index >= arr.length) throw 'Index out of bounds';
    return arr[index];
  }
"""

extern llvm """
define void @assertInboundsByteArray(i64 %index, %Pos %arr) alwaysinline {
  %size = extractvalue %Pos %arr, 0
  %in_bounds = icmp ult i64 %index, %size
  br i1 %in_bounds, label %ok, label %out
out:
  call void @exit(i64 1)
  unreachable
ok:
  ret void
}
"""

extern def get(arr: ByteArray, index: Int) at global: Byte =
  js "bytearray$get(${arr}, ${index})"
  llvm """
    call void @assertInboundsByteArray(i64 ${index}, %Pos ${arr})
    %arr_ptr = extractvalue %Pos ${arr}, 1
    %arr_data_ptr = getelementptr inbounds i8, ptr %arr_ptr, i64 16
    %element_ptr = getelementptr inbounds i8, ptr %arr_data_ptr, i64 ${index}
    %element = load i8, ptr %element_ptr, align 1
    tail call void @erasePositive(%Pos ${arr})
    ret i8 %element
  """
  chez "(bytevector-u8-ref ${arr} ${index})"
  vm "bytearray::get(ByteArray, Int)"

extern def set(arr: ByteArray, index: Int, value: Byte) at global: Unit =
  js "bytearray$set(${arr}, ${index}, ${value})"
  llvm """
    call void @assertInboundsByteArray(i64 ${index}, %Pos ${arr})
    %arr_ptr = extractvalue %Pos ${arr}, 1
    %arr_data_ptr = getelementptr inbounds i8, ptr %arr_ptr, i64 16
    %element_ptr = getelementptr inbounds i8, ptr %arr_data_ptr, i64 ${index}
    store i8 ${value}, ptr %element_ptr, align 1
    tail call void @erasePositive(%Pos ${arr})
    ret %Pos zeroinitializer
  """
  chez "(bytevector-u8-set! ${arr} ${index} ${value})"
  vm "bytearray::set(ByteArray, Int, Byte)"

/// Creates a new ByteArray of size `size` filled with the value `init`
def bytearray(size: Int, init: Byte): ByteArray = {
  val arr = allocate(size);
  each(0, size) { i =>
    set(arr, i, init)
  };
  arr
}

def resize(source: ByteArray, size: Int): ByteArray = {
  val target = allocate(size)
  val n = min(source.size, target.size)
  def go(i: Int): ByteArray =
    if (i < n) {
      target.set(i, source.get(i))
      go(i + 1)
    } else {
      target
    }
  go(0)
}

def foreach(arr: ByteArray){ action: Byte => Unit }: Unit =
  each(0, arr.size) { i =>
    action(arr.get(i))
  }

def foreach(arr: ByteArray){ action: (Byte) {Label} => Unit }: Unit =
  each(0, arr.size) { (i) {label} =>
    action(arr.get(i)) {label}
  }

def foreachIndex(arr: ByteArray){ action: (Int, Byte) => Unit }: Unit =
  each(0, arr.size) { i =>
    action(i, arr.get(i))
  }

def foreachIndex(arr: ByteArray){ action: (Int, Byte) {Label} => Unit }: Unit =
  each(0, arr.size) { (i) {label} =>
    action(i, arr.get(i)) {label}
  }

extern def fromString(str: String) at {}: ByteArray =
  js "(new TextEncoder().encode(${str}))"
  llvm """
    ret %Pos ${str}
  """
  chez "(string->utf8 ${str})"
  vm "bytearray::fromString(String)"

extern def toString(arr: ByteArray) at {}: String =
  js "(new TextDecoder('utf-8').decode(${arr}))"
  // assuming the buffer is already in UTF-8
  llvm """
    ret %Pos ${arr}
  """
  chez "(utf8->string ${arr})"
  vm "bytearray::toString(ByteArray)"

def toHexCharBytes(b: Byte): Unit / emit[Byte] = {
  val unsigned: Int = b.toInt.bitwiseAnd(0xFF.toInt)

  val high = unsigned.bitwiseShr(4).bitwiseAnd(0xFF.toInt)
  val low = unsigned.bitwiseAnd(0x0F.toInt)

  def toHexDigit(n: Int): Byte =
    if (n < 10) {
      (n + 48)       // '0' = 48
    } else {
      (n - 10 + 65)  // 'A' = 65
    }.toByte

  do emit(high.toHexDigit)
  do emit(low.toHexDigit)
}

/// Converts a byte like `0xAB` into a bytearray `bytearray.['0', 'x', 'A', 'B']"`
def toHexCharBytes(b: Byte): ByteArray = collect {
  do emit(0x30) // '0'
  do emit(0x78) // 'x'
  b.toHexCharBytes
}

/// Converts a bytearray like `bytearray.[0xAB, 0xFF]` into a bytearray `bytearray.['A', 'B', 'F', 'F']"`
def toHexCharBytes(arr: ByteArray): ByteArray = collect {
  for[Byte] {arr.each} { b => b.toHexCharBytes }
}

// NOTE: It seems like these cannot really be defined earlier... Oh well.

def show(b: Byte): String = b.toHexCharBytes.toString
def println(b: Byte): Unit = println(show(b))

extern js """
  function bytearray$set(bytes, index, value) {
    bytes[index] = value;
    return $effekt.unit;
  }

  function bytearray$compare(arr1, arr2) {
    const len = Math.min(arr1.length, arr2.length);

    for (let i = 0; i < len; i++) {
      if (arr1[i] !== arr2[i]) {
        return arr1[i] < arr2[i] ? -1 : 1;
      }
    }

    if (arr1.length !== arr2.length) {
      return arr1.length < arr2.length ? -1 : 1;
    } else {
      return 0;
    }
  }
"""

extern llvm """
define void @bytearray_erase_noop(ptr readnone %0) {
  ret void
}
"""

extern chez """
  (define (bytearray$compare b1 b2)
    (let ([len1 (bytevector-length b1)]
          [len2 (bytevector-length b2)]
          [minlen (min (bytevector-length b1) (bytevector-length b2))])
      (let loop ([i 0])
        (cond
          [(= i minlen)
          (cond [(< len1 len2) -1]
                [(> len1 len2) 1]
                [else 0])]
          [(< (bytevector-u8-ref b1 i) (bytevector-u8-ref b2 i)) -1]
          [(> (bytevector-u8-ref b1 i) (bytevector-u8-ref b2 i)) 1]
          [else (loop (+ i 1))]))))
"""

extern def compareByteArrayImpl(b1: ByteArray, b2: ByteArray) at {}: Int =
  js "bytearray$compare(${b1}, ${b2})"
  llvm """
    %x = call %Int @c_bytearray_compare(%Pos ${b1}, %Pos ${b2})
    ret %Int %x
  """
  chez "(bytearray$compare ${b1} ${b2})"
  vm "bytearray::compare(ByteArray, ByteArray)"

def compareByteArray(b1: ByteArray, b2: ByteArray): Ordering = {
  val ret = compareByteArrayImpl(b1, b2)
  if (ret == 0) {
    Equal()
  } else if (ret < 0) {
    Less()
  } else { // ret > 0
    Greater()
  }
}

def compareStringBytes(left: String, right: String): Ordering = {
  val l = left.fromString
  val r = right.fromString
  compareByteArray(l, r)
}


// Streaming
// ---------

/// Turns `bytes` into a producer of a push stream
/// by emitting each contained value from 0 to length - 1.
def each(bytes: ByteArray): Unit / emit[Byte] = {
  val n = bytes.size
  def go(i: Int): Unit = {
    if (i < n) {
      do emit(bytes.get(i))
      go(i + 1)
    }
  }
  go(0)
}

def feed[R](bytes: ByteArray) { reader: () => R / read[Byte] }: R = {
  var i = 0
  try {
    reader()
  } with read[Byte] {
    resume {
      if (i < bytes.size) {
        val c = i
        i = c + 1
        bytes.get(c)
      } else {
        do stop()
      }
    }
  }
}

def collect { stream: () => Unit / emit[Byte] }: ByteArray =
  returning::collect[Unit]{stream}.second

namespace returning {
  def collect[R] { stream: () => R / emit[Byte] }: (R, ByteArray) = {
    var i = 0
    var a = allocate(1)
    try {
      (stream(), a.resize(i))
    } with emit[Byte] { (v) =>
      if (i >= a.size) { a = a.resize(2 * a.size) }
      a.set(i, v)
      i = i + 1
      resume(())
    }
  }
}
