module dictionary

import array
import bytearray
import stream


/// A trie-based dictionary for efficient key-value storage with bytearray keys.
/// Supports String and ByteArray keys with fast lookup and insertion.
type Dictionary[A] {
  Empty()
  Leaf(value: A)
  Branch(children: Array[Dictionary[A]])
  Node(value: A, children: Array[Dictionary[A]])
}

/// Insert a value with a String key.
def insert[A](trie: Dictionary[A], key: String, value: A): Dictionary[A] =
  insert(trie, key.fromString, value)

/// Insert a key-value pair into the dictionary with a ByteArray key.
def insert[A](trie: Dictionary[A], key: ByteArray, value: A): Dictionary[A] = {
  def go(trie: Dictionary[A], i: Int): Dictionary[A] =
    if (i < key.size) {
      trie match {
        case Empty() =>
          val child = go(Empty(), i + 1)
          val children = array(256, Empty())
          children.set(key.get(i).toInt, child)
          Branch(children)
        case Leaf(existing) =>
          val child = go(Empty(), i + 1)
          val children = array(256, Empty())
          children.set(key.get(i).toInt, child)
          Node(existing, children)
        case Branch(children) =>
          val child = go(children.get(key.get(i).toInt), i + 1)
          children.set(key.get(i).toInt, child)
          Branch(children)
        case Node(existing, children) =>
          val child = go(children.get(key.get(i).toInt), i + 1)
          children.set(key.get(i).toInt, child)
          Node(existing, children)
      }
    } else {
      trie match {
        case Empty() => Leaf(value)
        case Leaf(_) => Leaf(value)
        case Node(_, children) => Node(value, children)
        case Branch(children) => Node(value, children)
      }
    }
  go(trie, 0)
}

/// Look up a value in the dictionary by string key.
def lookup[A](trie: Dictionary[A], key: String): Option[A] =
  lookup(trie, key.fromString)

/// Look up a value in the dictionary by bytearray key.
def lookup[A](trie: Dictionary[A], key: ByteArray): Option[A] = {
  def go(trie: Dictionary[A], i: Int): Option[A] =
    if (i < key.size) {
      trie match {
        case Empty() => None()
        case Leaf(_) => None()
        case Branch(children) => go(children.get(key.get(i).toInt), i + 1)
        case Node(_, children) => go(children.get(key.get(i).toInt), i + 1)
      }
    } else {
      trie match {
        case Empty() => None()
        case Leaf(value) => Some(value)
        case Branch(_) => None()
        case Node(value, _) => Some(value)
      }
    }
  go(trie, 0)
}

/// A record pairing a key with a value for use in streams.
record Tagged[A](key: ByteArray, value: A)

/// Collect key-value pairs from a stream of Tagged elements into a Dictionary.
def collect[A] { stream: () => Unit / emit[Tagged[A]] }: Dictionary[A] = {
  var trie = Empty()
  for[Tagged[A]] { stream() } { case Tagged(bytes, value) =>
    trie = trie.insert(bytes, value)
  }
  return trie
}

/// Emit all values stored in the dictionary as a push stream.
def each[A](trie: Dictionary[A]): Unit / emit[A] =
  trie match {
    case Empty() => ()
    case Leaf(value) => do emit(value)
    case Branch(children) =>
      each(0, children.size) { i =>
        each(children.get(i))
      }
    case Node(value, children) =>
      do emit(value)
      each(0, children.size) { i =>
        each(children.get(i))
      }
  }

/// Emit all key-value pairs stored in the dictionary as a push stream of Tagged elements.
def eachTagged[A](trie: Dictionary[A]): Unit / emit[Tagged[A]] = {
  def fromBytesReverse(bytes: List[Byte], n: Int): ByteArray = {
    val key = bytearray::allocate(n)
    foreachIndex(bytes) { (i, b) => key.set(n - 1 - i, b) }
    key
  }
  def go(trie: Dictionary[A], key: List[Byte], n: Int): Unit =
    trie match {
      case Empty() => ()
      case Leaf(value) => do emit(Tagged(fromBytesReverse(key, n), value))
      case Branch(children) =>
        each(0, children.size) { i =>
          go(children.get(i), Cons(i.toByte, key), n + 1)
        }
      case Node(value, children) =>
        do emit(Tagged(fromBytesReverse(key, n), value))
        each(0, children.size) { i =>
          go(children.get(i), Cons(i.toByte, key), n + 1)
        }
    }
  go(trie, Nil(), 0)
}


