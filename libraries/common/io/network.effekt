module io/network

import bytearray

import io/error


/// A tcp handle. Should not be inspected.
type Connection = Int

def connect(host: String, port: Int): Connection / Exception[IOError] =
  internal::checkResult(internal::connect(host, port))

def read(handle: Connection, buffer: ByteArray, offset: Int, size: Int): Int / Exception[IOError] =
  internal::checkResult(internal::read(handle, buffer, offset, size))

def write(handle: Connection, buffer: ByteArray, offset: Int, size: Int): Int / Exception[IOError] =
  internal::checkResult(internal::write(handle, buffer, offset, size))

def close(handle: Connection): Unit =
  internal::close(handle)

/// A tcp listener. Should not be inspected.
type Listener = Int

def bind(host: String, port: Int): Listener / Exception[IOError] =
  internal::checkResult(internal::bind(host, port))

def listen(listener: Listener, handler: Connection => Unit at {io, async, global}): Unit / Exception[IOError] = {
  internal::checkResult(internal::listen(listener, handler)); ()
}

def shutdown(listener: Listener): Unit =
  internal::shutdown(listener)

namespace internal {

  extern llvm """
    declare void @c_tcp_connect(%Pos, %Int, %Stack)
    declare void @c_tcp_read(%Int, %Pos, %Int, %Int, %Stack)
    declare void @c_tcp_write(%Int, %Pos, %Int, %Int, %Stack)
    declare void @c_tcp_close(%Int, %Stack)
    declare void @c_tcp_bind(%Pos, %Int, %Int, %Stack)
    declare void @c_tcp_listen(%Int, %Pos, %Stack)
    declare void @c_tcp_shutdown(%Int, %Stack)
  """

  extern async def connect(host: String, port: Int): Int =
    llvm """
      call void @c_tcp_connect(%Pos ${host}, %Int ${port}, %Stack %stack)
      ret void
    """

  /// The buffer must be kept alive by using it after the call
  extern async def read(handle: Int, buffer: ByteArray, offset: Int, size: Int): Int =
    llvm """
      call void @c_tcp_read(%Int ${handle}, %Pos ${buffer}, %Int ${offset}, %Int ${size}, %Stack %stack)
      ret void
    """

  /// The buffer must be kept alive by using it after the call
  extern async def write(handle: Int, buffer: ByteArray, offset: Int, size: Int): Int =
    llvm """
      call void @c_tcp_write(%Int ${handle}, %Pos ${buffer}, %Int ${offset}, %Int ${size}, %Stack %stack)
      ret void
    """

  extern async def close(handle: Int): Unit =
    llvm """
      call void @c_tcp_close(%Int ${handle}, %Stack %stack)
      ret void
    """

  extern async def bind(host: String, port: Int): Int =
    llvm """
      call void @c_tcp_bind(%Pos ${host}, %Int ${port}, %Stack %stack)
      ret void
    """

  extern async def listen(listener: Int, handler: Int => Unit at {io, async, global}): Int =
    llvm """
      call void @c_tcp_listen(%Int ${listener}, %Pos ${handler}, %Stack %stack)
      ret void
    """

  extern async def shutdown(handle: Int): Unit =
    llvm """
      call void @c_tcp_shutdown(%Int ${handle}, %Stack %stack)
      ret void
    """

}


