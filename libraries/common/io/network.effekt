module io/network

import bytearray

import io/error


/// A tcp handle. Should not be inspected.
type Connection = Int

def connect(host: String, port: Int): Connection / Exception[IOError] =
  internal::checkResult(internal::connect(host, port))

def read(handle: Connection, buffer: ByteArray, offset: Int, size: Int): Int / Exception[IOError] =
  internal::checkResult(internal::read(handle, buffer, offset, size))

def write(handle: Connection, buffer: ByteArray, offset: Int, size: Int): Int / Exception[IOError] =
  internal::checkResult(internal::write(handle, buffer, offset, size))

def close(handle: Connection): Unit / Exception[IOError] = {
  internal::checkResult(internal::close(handle)); ()
}

/// A tcp listener. Should not be inspected.
type Listener = Int

def listen(host: String, port: Int, backlog: Int): Listener / Exception[IOError] =
  internal::checkResult(internal::listen(host, port, backlog))

def accept(listener: Listener): Connection / Exception[IOError] =
  internal::checkResult(internal::accept(listener))

def close_listener(listener: Listener): Unit / Exception[IOError] = {
  internal::checkResult(internal::close_listener(listener)); ()
}

namespace internal {

  extern llvm """
    declare void @c_tcp_connect(%Pos, %Int, %Stack)
    declare void @c_tcp_read(%Int, %Pos, %Int, %Int, %Stack)
    declare void @c_tcp_write(%Int, %Pos, %Int, %Int, %Stack)
    declare void @c_tcp_close(%Int, %Stack)
    declare void @c_tcp_listen(%Pos, %Int, %Int, %Stack)
    declare void @c_tcp_accept(%Int, %Stack)
    declare void @c_tcp_close_listener(%Int, %Stack)
  """

 extern async def connect(host: String, port: Int): Int =
   llvm """
     call void @c_tcp_connect(%Pos ${host}, %Int ${port}, %Stack %stack)
     ret void
   """

 extern async def read(handle: Int, buffer: ByteArray, offset: Int, size: Int): Int =
   llvm """
     call void @c_tcp_read(%Int ${handle}, %Pos ${buffer}, %Int ${offset}, %Int ${size}, %Stack %stack)
     ret void
   """

 extern async def write(handle: Int, buffer: ByteArray, offset: Int, size: Int): Int =
   llvm """
     call void @c_tcp_write(%Int ${handle}, %Pos ${buffer}, %Int ${offset}, %Int ${size}, %Stack %stack)
     ret void
   """

 extern async def close(handle: Int): Int =
   llvm """
     call void @c_tcp_close(%Int ${handle}, %Stack %stack)
     ret void
   """

 extern async def listen(host: String, port: Int, backlog: Int): Int =
   llvm """
     call void @c_tcp_listen(%Pos ${host}, %Int ${port}, %Int ${backlog}, %Stack %stack)
     ret void
   """

 extern async def accept(listener: Int): Int =
   llvm """
     call void @c_tcp_accept(%Int ${listener}, %Stack %stack)
     ret void
   """

  extern async def close_listener(handle: Int): Int =
    llvm """
      call void @c_tcp_close_listener(%Int ${handle}, %Stack %stack)
      ret void
    """

}


