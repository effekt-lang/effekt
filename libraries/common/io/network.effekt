module io/network

import stream
import bytearray

import io/error


/// A TCP handle. Should not be inspected.
type Connection = Int

/// Reads data from a TCP connection into a buffer at the given offset.
def read(handle: Connection, buffer: ByteArray, offset: Int, size: Int): Int / Exception[IOError] =
  internal::checkResult(internal::read(handle, buffer, offset, size))

/// Writes data from a buffer at the given offset to a TCP connection.
def write(handle: Connection, buffer: ByteArray, offset: Int, size: Int): Int / Exception[IOError] =
  internal::checkResult(internal::write(handle, buffer, offset, size))

/// Establishes a TCP connection to the specified host and port.
def connect(host: String, port: Int): Connection / Exception[IOError] =
  internal::checkResult(internal::connect(host, port))

/// Closes a TCP connection and releases associated resources.
def close(handle: Connection): Unit =
  internal::close(handle)

/// A TCP listener. Should not be inspected.
type Listener = Int

/// Creates a TCP listener bound to the specified host and port.
def bind(host: String, port: Int): Listener / Exception[IOError] =
  internal::checkResult(internal::bind(host, port))

/// Starts listening for incoming connections and handles them with the provided handler function.
/// Runs until `shutdown` is called on this `Listener`.
def listen(listener: Listener, handler: Connection => Unit at {io, async, global}): Unit / Exception[IOError] = {
  internal::checkResult(internal::listen(listener, handler)); ()
}

/// Stops a TCP listener and releases associated resources.
def shutdown(listener: Listener): Unit =
  internal::shutdown(listener)


def streaming[R](connection: Connection) { stream: () => R / {read[ByteArray], emit[ByteArray]} }: R / Exception[IOError] =
  try {
    val r = stream()
    close(connection)
    return r
  } with emit[ByteArray] { bytes =>
    write(connection, bytes, 0, bytes.size)
    resume(())
  } with read[ByteArray] { () =>
    val bytes = bytearray::allocate(4096)
    read(connection, bytes, 0, bytes.size) match {
      case r and r == bytes.size => resume { return bytes }
      case r => resume { bytes.resize(r) }
    }
  }


namespace internal {

  extern llvm """
    declare void @c_tcp_connect(%Pos, %Int, %Stack)
    declare void @c_tcp_read(%Int, %Pos, %Int, %Int, %Stack)
    declare void @c_tcp_write(%Int, %Pos, %Int, %Int, %Stack)
    declare void @c_tcp_close(%Int, %Stack)
    declare void @c_tcp_bind(%Pos, %Int, %Int, %Stack)
    declare void @c_tcp_listen(%Int, %Pos, %Stack)
    declare void @c_tcp_shutdown(%Int, %Stack)
  """

  extern def connect(host: String, port: Int) at async: Int =
    llvm """
      call void @c_tcp_connect(%Pos ${host}, %Int ${port}, %Stack %stack)
      ret void
    """

  /// The buffer must be kept alive by using it after the call
  extern def read(handle: Int, buffer: ByteArray, offset: Int, size: Int) at async: Int =
    llvm """
      call void @c_tcp_read(%Int ${handle}, %Pos ${buffer}, %Int ${offset}, %Int ${size}, %Stack %stack)
      ret void
    """

  /// The buffer must be kept alive by using it after the call
  extern def write(handle: Int, buffer: ByteArray, offset: Int, size: Int) at async: Int =
    llvm """
      call void @c_tcp_write(%Int ${handle}, %Pos ${buffer}, %Int ${offset}, %Int ${size}, %Stack %stack)
      ret void
    """

  extern def close(handle: Int) at async: Unit =
    llvm """
      call void @c_tcp_close(%Int ${handle}, %Stack %stack)
      ret void
    """

  extern def bind(host: String, port: Int) at io: Int =
    llvm """
      %result = call %Int @c_tcp_bind(%Pos ${host}, %Int ${port})
      ret %Int %result
    """

  extern def listen(listener: Int, handler: Int => Unit at {io, async, global}) at async: Int =
    llvm """
      call void @c_tcp_listen(%Int ${listener}, %Pos ${handler}, %Stack %stack)
      ret void
    """

  extern def shutdown(handle: Int) at async: Unit =
    llvm """
      call void @c_tcp_shutdown(%Int ${handle}, %Stack %stack)
      ret void
    """

}


