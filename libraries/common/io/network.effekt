module io/network

import bytearray

import io/error


/// A tcp handle. Should not be inspected.
type Connection = Int

def connect(host: String, port: Int): Connection / Exception[IOError] =
  internal::checkResult(internal::connect(host, port))

def read(handle: Connection, buffer: ByteArray, offset: Int, size: Int): Int / Exception[IOError] =
  internal::checkResult(internal::read(handle, buffer, offset, size))

def write(handle: Connection, buffer: ByteArray, offset: Int, size: Int): Int / Exception[IOError] =
  internal::checkResult(internal::write(handle, buffer, offset, size))

def close(handle: Connection): Unit / Exception[IOError] = {
  internal::checkResult(internal::close(handle)); ()
}


namespace internal {

  extern llvm """
    declare void @c_tcp_connect(%Pos, %Int, %Stack)
    declare void @c_tcp_read(%Int, %Pos, %Int, %Int, %Stack)
    declare void @c_tcp_write(%Int, %Pos, %Int, %Int, %Stack)
    declare void @c_tcp_close(%Int, %Stack)
  """

 extern async def connect(host: String, port: Int): Int =
   llvm """
     call void @c_tcp_connect(%Pos ${host}, %Int ${port}, %Stack %stack)
     ret void
   """

 extern async def read(handle: Int, buffer: ByteArray, offset: Int, size: Int): Int =
   llvm """
     call void @c_tcp_read(%Int ${handle}, %Pos ${buffer}, %Int ${offset}, %Int ${size}, %Stack %stack)
     ret void
   """

 extern async def write(handle: Int, buffer: ByteArray, offset: Int, size: Int): Int =
   llvm """
     call void @c_tcp_write(%Int ${handle}, %Pos ${buffer}, %Int ${offset}, %Int ${size}, %Stack %stack)
     ret void
   """

 extern async def close(handle: Int): Int =
   llvm """
     call void @c_tcp_close(%Int ${handle}, %Stack %stack)
     ret void
   """

}


