module io/promise

import io
import io/signal

// Promises
// --------

type State[T] {
  Resolved(value: T)
  Pending(signals: List[Signal[T, Unit]])
}

type Promise[T] = Ref[State[T]]

namespace promise {
  def make[T](): Promise[T] =
    ref(Pending(Nil()))
}

def promise[T](task: Task[T]): Promise[T] = {
  val p = promise::make[T]();
  spawn(box { p.resolve(task()) });
  return p
}

def await[T](promise: Promise[T]): T = {
  promise.get match {
    case Resolved(value) =>
      return value
    case Pending(signals) =>
      val signal = signal::allocate()
      promise.set(Pending(Cons(signal, signals)))
      // TODO perhaps yield to avoid stack overflow
      signal.unsafeWait(())
  }
}

def resolve[T](promise: Promise[T], value: T): Unit = {
  promise.get match {
    case Resolved(value) =>
      panic("ERROR: Promise already resolved")
    case Pending(signals) =>
      promise.set(Resolved(value))
      // TODO perhaps yield to avoid stack overflow
      signals.reverse.foreach { signal => unsafeFire(signal, value) }
  }
}

