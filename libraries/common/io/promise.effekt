module io/promise

import io

// Futures
// -------

extern type Future[T]

namespace future {
  extern global def allocate[T](): Future[T] =
    llvm """
      %future = call %Pos @c_future_make()
      ret %Pos %future
    """
}

extern global def fill[T](future: Future[T], value: T): Unit =
  llvm """
    call void @c_future_fill(%Pos ${future}, %Pos ${value})
    ret %Pos zeroinitializer
  """

extern async def wait[T](future: Future[T]): T =
  llvm """
    call void @c_future_wait(%Pos ${future}, %Stack %stack)
    ret void
  """

extern llvm """
  declare %Pos @c_future_make()
  declare void @c_future_fill(%Pos, %Pos)
  declare void @c_future_wait(%Pos, %Stack)
"""

// Promises
// --------

type State[T] {
  Resolved(value: T)
  Pending(futures: List[Future[T]])
}

extern type Promise[T]
  // = js "{resolve: Æ’, promise: Promise}"
  // = llvm "Ref[State[T]]"

extern pure def toPromise[T](promise: Ref[State[T]]): Promise[T] =
  llvm """
    ret %Pos ${promise}
  """

extern pure def toRefState[T](promise: Promise[T]): Ref[State[T]] =
  llvm """
    ret %Pos ${promise}
  """

namespace promise {
  extern global def make[T](): Promise[T] =
    js "promise$make()"
    llvm { toPromise(ref(Pending(Nil()))) }
}

def promise[T](task: Task[T]): Promise[T] = {
  val p = promise::make[T]();
  spawn(box { p.resolve(task()) });
  return p
}

extern {async, global} def await[T](promise: Promise[T]): T =
  js "$effekt.capture(k => ${promise}.promise.then(k))"
  llvm {
    val reference = toRefState(promise)
    // TODO use reference.get
    get(reference) match {
      case Resolved(value) =>
        return value
      case Pending(futures) =>
        val future = future::allocate()
        // TODO user reference.set and future.wait
        set(reference, Pending(Cons(future, futures)))
        wait(future)
    }
  }

extern {io, global} def resolve[T](promise: Promise[T], value: T): Unit =
  js "promise$resolve(${promise}, ${value})"
  llvm {
    val reference = toRefState(promise)
    // TODO use reference.get
    get(reference) match {
      case Resolved(value) =>
        panic("ERROR: Promise already resolved")
      case Pending(futures) =>
        // TODO use reference.set
        set(reference, Resolved(value))
        futures.reverse.foreach { future => future.fill(value) }
    }
  }


extern js """
  function promise$make() {
    let resolve;
    const promise = new Promise((res, rej) => {
      resolve = res;
    });
    return { resolve: resolve, promise: promise };
  }

  function promise$resolve(promise, value) {
    promise.resolve(value);
    return $effekt.unit
  }
"""
