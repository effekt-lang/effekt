module scanner

import char
import stream

interface Scan[A] {
  /// Return the next character, not advancing.
  /// That is, this does not change what any future calls on the Scanner return.
  def peek(): A / stop
  /// Advance the Scanner to the next character.
  def skip(): Unit
}

/// Advance the Scanner to the next character, returning it.
def next[A](): A / { Scan[A], stop } = {
  val t = do peek[A]()
  do skip[A]()
  t
}


def scanner[A, R] { scanner: () => R / Scan[A] }: R / read[A] = {
  var last = None()
  try {
    scanner()
  } with Scan[A] {
    def peek() = resume {
      last match {
        case None() =>
          val t = do read[A]()
          last = Some(t)
          return t
        case Some(t) =>
          return t
      }
    }
    def skip() =
      resume(last = None())
  }
}


record UnexpectedChar(got: Option[Char], expected: Option[Char])

def prettyUnexpectedChar(got: Option[Char], expected: Option[Char]): String = (got, expected) match {
  case (Some(gotChar), Some(expectedChar)) =>
    "Unexpected character, got '" ++ gotChar.toString ++ "', but expected '" ++ expectedChar.toString ++ "'"
  case (None(), Some(expectedChar)) =>
    "Unexpected end of input, expected '" ++ expectedChar.toString ++ "'"
  case (Some(gotChar), None()) =>
    "Unexpected character, got '" ++ gotChar.toString ++ "', but expected end of input"
  case (None(), None()) =>
    "Unexpected character"
}

def unexpectedChar(got: Option[Char], expected: Option[Char]): Nothing / Exception[UnexpectedChar] =
  do raise(UnexpectedChar(got, expected), prettyUnexpectedChar(got, expected))

def unexpectedChar(got: Option[Char], expected: Char): Nothing / Exception[UnexpectedChar] =
  unexpectedChar(got, Some(expected))

/// Check that the next character is the given one, raising an exception otherwise.
def expect(c: Char): Unit / { Scan[Char], Exception[UnexpectedChar] } =
  try {
    val t = do peek[Char]()
    if(t == c) {
      do skip[Char]()
    } else {
      unexpectedChar(Some(t), c)
    }
  } with stop {
    unexpectedChar(None(), c)
  }

/// Check that there is no further input, raising an exception otherwise.
def expectEof(): Unit / { Scan[Char], Exception[UnexpectedChar] } =
  boundary {
    unexpectedChar(Some(do peek[Char]()), None())
  }


/// Check that the next characters are the given String, raising an exception otherwise.
/// Advances over the longest common prefix with this String.
def expect(s: String): Unit / { Scan[Char], Exception[UnexpectedChar] } =
  for[Char] { s.each } { c => expect(c) }


/// If the next character is c, advance over it and return true.
/// Else return false.
def skip(c: Char): Bool / Scan[Char] = {
  try {
    if (do peek() == c) { do skip[Char](); true } else { false }
  } with stop {
    false
  }
}

/// Skip until the next character is not a whitespace character
def skipWhitespace(): Unit / Scan[Char] =
  exhaustively {
    val c = do peek[Char]()
    if (c.isWhitespace) {
      do skip[Char]()
    } else {
      do stop()
    }
  }

/// Reads until the predicate does not hold for the next token.
/// Emits the tokens skipped.
def consume[A] { predicate: A => Bool }: Unit / { Scan[A], emit[A] } =
  exhaustively {
    val c = do peek[A]()
    if (predicate(c)) {
      do skip[A]()
      do emit(c)
    } else {
      do stop()
    }
  }

/// Read a positive decimal integer.
def readPositive(): Int / { Scan[Char], Exception[WrongFormat] } = {
  readPositive(10)
}

/// Read a positive integer in the given base <= 35.
def readPositive(base: Int): Int / { Scan[Char], Exception[WrongFormat] } = {

  var result = try digitValue(next()) with stop { 
    wrongFormat("Positive number should start with a digit")
  }
  
  try {
    while(digitValue(do peek(), base) is digit) {
      do skip[Char]()
      result = result * base + digit
    }
    result
  } with stop {
    result
  } with Exception[WrongFormat] {
    def raise(_, _) = result
  }
}

/// Read an integer in the given base <= 35.
def readInt(base: Int): Int / { Scan[Char], Exception[WrongFormat] } = {
  if(skip('-')) {
    0 - readPositive(base)
  } else {
    readPositive(base)
  }
}

/// Read a decimal integer.
def readInt(): Int / { Scan[Char], Exception[WrongFormat] } =
  readInt(10)

/// Read a double value, in the common format (TODO document)
def readDouble(): Double / { Scan[Char], Exception[WrongFormat] } = {
  def exponent(pre: Double) = {
    try {
      if(do peek() == 'e' || do peek() == 'E') {
        do skip[Char]()
        val e = do peek[Char]() match {
          case '+' => do skip[Char](); readPositive()
          case '-' => do skip[Char](); 0 - readPositive()
          case _ => readPositive()
        }
        pre * pow(10.0, e)
      } else { pre }
    } with stop {
      pre
    }
  }
  def fraction(pre: Int) = {
    try {
      if (do peek[Char]() is '.') {
        skip('.')
        var b = 0.1
        var r = pre.toDouble
        try {
          while (digitValue(do peek()) is d) {
            do skip[Char]()
            r = r + b * d.toDouble
            b = b * 0.1
          }
        } with stop {
          ()
        } with Exception[WrongFormat] {
          def raise(e, m) = () 
        }
        exponent(r)
      } else { pre.toDouble }
    } with stop {
      pre.toDouble
    }
  }
  fraction(readInt())
}

/// Read and unescape a string in ""
def readQuotedString(): Unit / { Scan[Char], emit[Char], Exception[WrongFormat] } = {
  try {
    skipWhitespace()
    expect('"')
    while(next[Char]() is c and c != '"') {
      c match {
        case '\\' => next[Char]() match {
          case '"' => do emit('\"')
          case '\\' => do emit('\\')
          case '/' => do emit('/')
          case 'b' => <>
          case 'f' => <>
          case 'n' => do emit('\n')
          case 'r' => do emit('\r')
          case 't' => do emit('\t')
          case c => wrongFormat("Invalid escape sequence '\\" ++ c.toString ++ "'")
        }
        case o => do emit(o)
      }
    }
    skip('\"')
    ()
  } with stop {
    wrongFormat("Unexpected end of file while reading a string")
  } with Exception[UnexpectedChar] {
    def raise(r, m) = wrongFormat(m)
  }
}

namespace test {
  def main() = {
    with on[UnexpectedChar].panic
    with on[WrongFormat].panic
  
    val input = """
    12
    32.3e-1
    "\ta\n\ra"
    """

    with feed(input)
    with scanner[Char, Unit]

    skipWhitespace()
    println(readInt().show)
    skipWhitespace()
    println(readDouble().show)
    skipWhitespace()
    println(collectString { readQuotedString() })
  }
}