module scanner

import stream

interface Scan[A] {
  /// Return the next character, not advancing.
  /// That is, this does not change what any future calls on the Scanner return.
  def peek(): A / stop
  /// Advance the Scanner to the next character.
  def skip(): Unit / stop
}


/// Advance the Scanner to the next token, returning it.
def read[A](): A / { Scan[A], stop } = {
  val t = do peek()
  do skip()
  return t
}


/// Run a scanner by reading from an input stream, discarding its output.
def scanner[A] { scanner: () => Unit / Scan[A] }: Unit / read[A] =
  returning::scanner[A, Unit]{scanner}

def expect(message: String) { scanner: () => Unit / fail }: Unit / Exception[WrongFormat] =
  returning::expect[Unit](message){scanner}

/// If conversion is successful read the next token, otherwise stop.
def readWhen[A, B] { convert: A => B / fail }: B / { Scan[A], stop } = {
  val t = attempt { convert(do peek()) } { do stop() };
  do skip();
  return t
}

/// Check that the next token satisfies the predicate and skip and return it when it does.
def readIf[A] { predicate: A => Bool }: A / { Scan[A], stop } = {
  val t = do peek()
  if (predicate(t)) {
    do skip()
    return t
  } else {
    do stop()
  }
}

/// Check that the next token satisfies the predicate and skip it when it does.
def skipIf[A] { predicate: A => Bool }: Unit / { Scan[A], stop } = {
  readIf{predicate}; ()
}


/// Reads until the predicate does not hold for the next token.
/// Emits the tokens read.
def readMany[A] { predicate: A => Bool }: Unit / { Scan[A], emit[A] } =
  many { readIf{predicate} }

/// Reads until the predicate does not hold for the next token.
/// Must read at least one token, else fails.
/// Emits the tokens read.
def readSome[A] { predicate: A => Bool }: Unit / { Scan[A], emit[A], fail } =
  some { readIf{predicate} }

/// Skips until the predicate does not hold for the next token.
def skipMany[A] { predicate: A => Bool }: Unit / Scan[A] =
  for[A] { readMany{predicate} } { _ => () }

/// Skips until the predicate does not hold for the next token.
/// Must skip at least one token, else fail.
def skipSome[A] { predicate: A => Bool }: Unit / { Scan[A], fail } =
  for[A] { readSome{predicate} } { _ => () }

/// Read the next character if it is the given one.
def readIf(e: Char): Unit / { Scan[Char], stop } = {
  readIf { c => c == e }; ()
}

/// Check that the next token satisfies the predicate and skip it when it does.
def skipIf(e: Char): Unit / { Scan[Char], stop } =
  skipIf { c => c == e }

/// Read values produced by `action` followed by `separator` until one of them stops.
/// Will consume a trailing separator.
def separating[A] { seperator: () => Unit / stop } { action: () => A / stop }: Unit / emit[A] =
  loop {
    do emit(action())
    seperator()
  }

/// Read a sequence separated by `separator`.
/// Will consume a trailing separator.
def separating[A](seperator: Char) { action: () => A / stop }: Unit / { Scan[Char], emit[A] } =
  separating { skipIf(seperator) } {action}


/// Skip until the next character is not a whitespace character.
def skipWhitespace(): Unit / Scan[Char] =
  skipMany { c => c.isWhitespace }

/// Read a prefix of the characters of the given string.
/// Fails when it cannot read all of them.
def readString(string: String): Unit / { Scan[Char], fail } =
  for[Char] { string.each } { char => must { readIf(char) } }

/// Check that the next character is a digit in base 10, and if so read and return it.
def readDigit(): Int / { Scan[Char], stop } =
  readWhen { char => digitValue(char) }

/// Read a positive decimal number.
/// Fails when there isn't at least one digit.
def readDecimal(): Int / { Scan[Char], fail } = {
  var result = must { readDigit() }
  for[Int] { many { readDigit() } } { digit =>
    result = result * 10 + digit
  }
  result
}

/// Check that the next character is a digit in base 16, and if so read and return it.
def readHexDigit(): Int / { Scan[Char], stop } =
  readWhen { char => hexDigitValue(char) }

/// Read a hexadecimal number.
/// Fails when there isn't at least one digit.
def readHexadecimal(): Int / { Scan[Char], fail } = {
  var result = must { readHexDigit() }
  for[Int] { many { readHexDigit() } } { digit =>
    result = result * 16 + digit
  }
  result
}

/// Read a decimal integer.
/// Will consume a minus sign if it is not followed by a digit.
/// Fails whenn there isn't at least one digit.
def readInteger(): Int / { Scan[Char], fail } =
  must { do peek() } match {
    case '-' => must { do skip() }; neg(readDecimal())
    case c and isDigit(c) => readDecimal()
    case _ => do fail()
  }

namespace returning {

/// Run a scanner by reading from an input stream.
def scanner[A, R] { scanner: () => R / Scan[A] }: R / read[A] = {
  var last = None()
  try {
    scanner()
  } with Scan[A] {
    def peek() = resume {
      last match {
        case None() =>
          val t = do read()
          last = Some(t)
          return t
        case Some(t) =>
          return t
      }
    }
    def skip() = resume {
      last match {
        case None() =>
          val _ = do read()
          return ()
        case Some(t) =>
          last = None()
          return ()
      }
    }
  }
}

def expect[R](message: String) { scanner: () => R / fail }: R / Exception[WrongFormat] =
  try { scanner() } with fail { wrongFormat(message) }

}


namespace test {
  def main(): Unit = {
  
    val input =
      """
      12
      -13
      A1B2
      """

    with on[WrongFormat].panic
    with expect("this grammar")
    with feed(input)
    with scanner[Char]

    skipWhitespace()
    println(readInteger().show)
    skipWhitespace()
    println(readInteger().show)
    skipWhitespace()
    println(readHexadecimal().show)
  }
}
