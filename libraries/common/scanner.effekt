module scanner

import char
import stream

interface Scan[A] {
  /// Return the next character, not advancing.
  /// That is, this does not change what any future calls on the Scanner return.
  def peek(): A / stop
  /// Advance the Scanner to the next character.
  def skip(): Unit / stop
}

/// Advance the Scanner to the next character, returning it.
def read[A](): A / { Scan[A], stop } = {
  val t = do peek[A]()
  do skip[A]()
  return t
}

/// Run a scanner by reading from an input stream.
def scanner[A, R] { scanner: () => R / Scan[A] }: R / read[A] = {
  var last = None()
  try {
    scanner()
  } with Scan[A] {
    def peek() = resume {
      last match {
        case None() =>
          val t = do read[A]()
          last = Some(t)
          return t
        case Some(t) =>
          return t
      }
    }
    def skip() = resume {
      last match {
        case None() =>
          val _ = do read[A]()
          return ()
        case Some(t) =>
          last = None()
          return ()
      }
    }
  }
}


effect fail(): Nothing

def successfully { action: () => Any / fail }: Unit =
  try {
    def go(): Unit = {
      action()
      go()
    }
    go()
  } with fail {
    ()
  }

def successfull[R] { program: () => R / fail }: Option[R] =
  try {
    Some(program())
  } with fail {
    None()
  }

def successfull { program: () => Any / fail }: Bool =
  successfull[Any]{program}.isDefined

def attempt[R] { program: () => R / fail } { fallback: () => R }: R =
  try {
    program()
  } with fail {
    fallback()
  }

/// Check that the next token satisfies the predicate and skip and return it when it does.
def readIf[A] { predicate: A => Bool }: A / { Scan[A], fail, stop } = {
  val t = do peek[A]()
  if (predicate(t)) {
    do skip[A]()
    return t
  } else {
    do fail()
  }
}

/// Check that the next token satisfies the predicate and skip it when it does.
def skipIf[A] { predicate: A => Bool }: Unit / { Scan[A], fail, stop } = {
  readIf{predicate}; ()
}

/// Reads until the predicate does not hold for the next token.
/// Emits the tokens read.
def readWhile[A] { predicate: A => Bool }: Unit / { Scan[A], emit[A], stop } =
  successfully { do emit(readIf{predicate}) }

/// Skips until the predicate does not hold for the next token.
def skipWhile[A] { predicate: A => Bool }: Unit / { Scan[A], stop } =
  for[A] { readWhile{predicate} } { _ => () }


/// Read the next character if it is the given one and return true in this case.
def readIf(e: Char): Unit / { Scan[Char], fail, stop } = {
  readIf[Char] { c => c == e}; ()
}

/// Check that the next token satisfies the predicate and skip it when it does.
def skipIf(e: Char): Unit / { Scan[Char], fail, stop } =
  skipIf { c => c == e }

/// Skip until the next character is not a whitespace character
def skipWhitespace(): Unit / { Scan[Char], stop } =
  skipWhile { c => c.isWhitespace }


def prettyUnexpectedChar(got: Char, expected: Char): String =
  "Unexpected character, got '" ++ got.toString ++ "', but expected '" ++ expected.toString ++ "'"

def unexpectedChar(got: Char, expected: Char): Nothing / Exception[WrongFormat] =
  wrongFormat(prettyUnexpectedChar(got, expected))

/// Expect a character class with a name and raise an exception if it fails or stops.
def expect[R](name: String) { scanner: () => R / {fail, stop} }: R / { Scan[Char], Exception[WrongFormat] } =
  try {
    try {
      scanner()
    } with fail {
      wrongFormat("Expected " ++ name ++ " but got " ++ do peek[Char]().toString)
    }
  } with stop {
    wrongFormat("Unexpected end of input")
  }

/// Require that the next character is the given one, raising an exception otherwise.
def expect(c: Char): Unit / { Scan[Char], Exception[WrongFormat] } =
  expect(c.toString) { readIf(c); () }

/// Check that the next characters are the given String, raising an exception otherwise.
/// Advances over the longest common prefix with this String.
def expect(s: String): Unit / { Scan[Char], Exception[WrongFormat] } =
  for[Char] { s.each } { c => expect(c); () }

/// Check that the next character is a digit in base 10, and if so read and return it.
def readDigit(): Int / { Scan[Char], fail, stop } =
  if (digitValue(do peek[Char]) is Some(d)) {
    do skip[Char]()
    return d
  } else {
    do fail()
  }

/// Read a positive decimal number.
def readDecimal(): Int / { Scan[Char], stop, Exception[WrongFormat] } = {
  var result = expect("digit") { readDigit() }
  for[Int] { successfully { readDigit() } } { digit =>
    result = result * 10 + digit
  }
  result
}

/// Check that the next character is a digit in base 16, and if so read and return it.
def readHexDigit(): Int / { Scan[Char], fail, stop } =
  if (hexDigitValue(do peek[Char]) is Some(d)) {
    do skip[Char]()
    return d
  } else {
    do fail()
  }

/// Read a hexadecimal number.
def readHexadecimal(): Int / { Scan[Char], stop, Exception[WrongFormat] } = {
  var result = expect("hexadecimal digit") { readHexDigit() }
  for[Int] { successfully { readHexDigit() } } { digit =>
    result = result * 16 + digit
  }
  result
}

/// Read a decimal integer.
def readInteger(): Int / { Scan[Char], stop, Exception[WrongFormat] } = {
  with attempt { readIf('-'); neg(readDecimal()) }
  readDecimal()
}

/// Read a double value, in the common format (TODO document)
def readDouble(): Double / { Scan[Char], stop, Exception[WrongFormat] } = {
  def exponent(pre: Double) = {
    try {
      if(do peek() == 'e' || do peek() == 'E') {
        do skip[Char]()
        val e = do peek[Char]() match {
          case '+' => do skip[Char](); readDecimal()
          case '-' => do skip[Char](); neg(readDecimal())
          case _ => readDecimal()
        }
        pre * pow(10.0, e)
      } else { pre }
    } with stop {
      pre
    }
  }
  def fraction(pre: Int) = {
    if (successfull { readIf('.') }) {
      var b = 0.1
      var r = pre.toDouble
      while (successfull[Int] { readDigit() } is Some(d)) {
        r = r + b * d.toDouble
        b = b * 0.1
      }
      exponent(r)
    } else {
      pre.toDouble
    }
  }
  fraction(readInteger())
}

/// Read and unescape a string in ""
def readQuotedString(): Unit / { Scan[Char], emit[Char], Exception[WrongFormat] } = {
  try {
    skipWhitespace()
    expect('"')
    while(read[Char]() is c and c != '"') {
      c match {
        case '\\' => read[Char]() match {
          case '"' => do emit('\"')
          case '\\' => do emit('\\')
          case '/' => do emit('/')
          case 'b' => <>
          case 'f' => <>
          case 'n' => do emit('\n')
          case 'r' => do emit('\r')
          case 't' => do emit('\t')
          case c => wrongFormat("Invalid escape sequence '\\" ++ c.toString ++ "'")
        }
        case o => do emit(o)
      }
    }
  } with stop {
    wrongFormat("Unexpected end of input while reading a string")
  }
}



namespace test {
  def main(): Unit = {
    with on[WrongFormat].panic
  
    val input =
      """
      12
      32.3e-1
      "\ta\n\ra"
      """

    with boundary
    with feed(input)
    with scanner[Char, Unit]

    skipWhitespace()
    println(readInteger().show)
    skipWhitespace()
    println(readDouble().show)
    skipWhitespace()
    println(collectString { readQuotedString() })
  }
}