module stream

import array
import bytearray
import io/filesystem
import io/error


effect emit[A](value: A): Unit

def for[A, R] { stream: () => R / emit[A] } { action: A => Unit }: R =
  try {
    stream()
  } with emit[A] { value =>
    resume(action(value))
  }

def for[A] { stream: () => Unit / emit[A] } { action: A => Unit }: Unit =
  for[A, Unit]{stream}{action}

def continually[A] { action: () => A }: Nothing / emit[A] = {
  def go(): Nothing = {
    do emit(action())
    go()
  }
  go()
}


def each[A](list: List[A]): Unit / emit[A] =
  list match {
    case Nil() => ()
    case Cons(head, tail) =>
      do emit(head)
      each(tail)
  }

def each[A](array: Array[A]): Unit / emit[A] = {
  val n = array.size
  def go(i: Int): Unit = {
    if (i < n) {
      do emit(array.unsafeGet(i))
      go(i + 1)
    }
  }
  go(0)
}

def each(bytes: ByteArray): Unit / emit[Byte] = {
  val n = bytes.size
  def go(i: Int): Unit = {
    if (i < n) {
      do emit(bytes.unsafeGet(i))
      go(i + 1)
    }
  }
  go(0)
}


// not option
// not dequeue
// not queue
// not result
// not seq


effect stop(): Nothing


def boundary[R] { program: () => R / stop }: Option[R] =
  try {
    Some(program())
  } with stop {
    def stop() = None()
  }

def exhaustively[A] { program: () => A / stop } { action: A => Unit }: Unit =
  try {
    def go(): Unit = {
      action(program())
      go()
    }
    go()
  } with stop {
    def stop() = ()
  }

record Indexed[A](index: Int, value: A)

// In Effekt lower bounds are inclusive and upper bounds are exclusive

def range(lower: Int, upper: Int): Unit / emit[Int] =
  if (lower < upper) {
    do emit(lower)
    range(lower + 1, upper)
  }

def rangeTo(upper: Int): Unit / emit[Int] =
  range(0, upper)

def rangeFrom(lower: Int): Unit / emit[Int] = {
  do emit(lower)
  rangeFrom(lower + 1)
}


def index[A, R] { stream: () => R / emit[A] }: R / emit[Indexed[A]] = {
  var i = 0;
  try {
    stream()
  } with emit[A] { v =>
    val c = i;
    i = c + 1;
    resume(do emit(Indexed(c, v)))
  }
}


def take[A, R](number: Int) { stream: () => R / emit[A] }: R / { emit[A], stop } = {
  var i = 0;
  try {
    stream()
  } with emit[A] { v =>
    val c = i;
    if (c < number) {
      i = c + 1;
      resume(do emit(v))
    } else {
      do stop()
    }
  }
}


// If `number` is zero or negative it does nothing (like `stream::take`)
def replicate[A](number: Int) { action: () => A }: Unit / emit[A] =
  if (number > 0) {
    do emit(action())
    replicate(number - 1) {action}
  }


def sum[R] { stream : () => R / emit[Int] }: (R, Int) = {
  var s = 0;
  try {
    (stream(), s)
  } with emit[Int] { v =>
    s = s + v;
    resume(())
  }
}

def sum { stream : () => Unit / emit[Int] }: Int =
  sum[Unit]{stream}.second

def collectList[A, R] { stream: () => R / emit[A] }: (R, List[A]) =
  try {
    (stream(), Nil())
  } with emit[A] {
    def emit(v) = {
      val (r, vs) = resume(());
      (r, Cons(v, vs))
    }
  }

def collectList[A] { stream: () => Unit / emit[A] }: List[A] =
  collectList[A, Unit]{stream}.second

def collectArray[A, R] { stream: () => R / emit[A] }: (R, Array[A]) = {
  var i = 0
  var a = array::allocate(1)
  try {
    (stream(), a.resize(i))
  } with emit[A] {
    def emit(v) = {
      if (i >= a.size) { a = a.resize(2 * a.size) }
      a.unsafeSet(i, v)
      i = i + 1
      resume(())
    }
  }
}

def collectArray[A] { stream: () => Unit / emit[A] }: Array[A] =
  collectArray[A, Unit]{stream}.second

def collectBytes[R] { stream: () => R / emit[Byte] }: (R, ByteArray) = {
  var i = 0
  var a = bytearray::allocate(1)
  try {
    (stream(), a.resize(i))
  } with emit[Byte] {
    def emit(v) = {
      if (i >= a.size) { a = a.resize(2 * a.size) }
      a.unsafeSet(i, v)
      i = i + 1
      resume(())
    }
  }
}

def collectBytes { stream: () => Unit / emit[Byte] }: ByteArray =
  collectBytes[Unit]{stream}.second



effect read[A](): A / stop


def source[A, R] { stream: () => Unit / emit[A] } { reader: () => R / read[A] }: R = {
  var next = box { () => None() }
  next = box { () =>
    try {
      stream()
      None()
    } with emit[A] {
      def emit(v) = {
        next = box { () => resume(()) }
        Some(v)
      }
    }
  }
  try {
    reader()
  } with read[A] { () =>
    resume {
      next().getOrElse { do stop() }
    }
  }
}


def writeFile[R](file: File) { stream: () => R / emit[Byte] }: R / Exception[IOError] = {

  val chunkSize = 1048576 // 1MB
  val buffer = bytearray::allocate(chunkSize)
  var offset = 0

  def push(i: Int, n: Int): Unit = {
    val r = write(file, buffer, i, n, -1)
    if (r < n) {
      push(i + r, n - r)
    }
  }

  try {
    val r = stream()
    push(0, offset)
    return r
  } with emit[Byte] {
    def emit(byte) = {
      if (offset >= buffer.size) { push(0, buffer.size) }
      buffer.unsafeSet(offset, byte)
      offset = offset + 1
      resume(())
    }
  }
}

def readFile[R](file: File) { reader: () => R / read[Byte] }: R / Exception[IOError] = {

  val chunkSize = 1048576 // 1MB
  val buffer = bytearray::allocate(chunkSize)
  var offset = 0
  var length = 0

  def pull(): Unit / stop = {
    read(file, buffer, 0, chunkSize, -1) match {
      case 0 =>
        do stop()
      case n =>
        offset = 0
        length = n
    }
  }

  try {
    reader()
  } with read[Byte] { () =>
    resume {
      if (offset >= length) { pull() }
      val byte = buffer.unsafeGet(offset)
      offset = offset + 1
      return byte
    }
  }
}

// TODO merge this with break
effect done[R](result: R): Nothing

def untilDone[R] { program: () => Unit / done[R] }: R =
  try {
    def go(): R = {
      program()
      go()
    }
    go()
  } with done[R] { result =>
    result
  }

def whenDone[R] { action: R => Unit } { program: () => Unit / done[R] }: Unit =
  try {
    program()
  } with done[R] { result =>
    action(result)
  }

type DecoderState {
  Initial()
  Expect1(acc: Int)
  Expect2(acc: Int)
  Expect3(acc: Int)
}

def decodeChar(state: DecoderState, byte: Byte): DecoderState / done[Char] = {
  val b = byte.toInt
  state match {
    case Initial() =>
      if (b < 128) {
        do done(b.toChar)
      } else if (b < 224) {
        Expect1(bitwiseAnd(b, 31))
      } else if (b < 240) {
        Expect2(bitwiseAnd(b, 15))
      } else {
        Expect3(bitwiseAnd(b, 7))
      }
    case Expect1(acc) =>
      do done(bitwiseOr(bitwiseShl(acc, 6), bitwiseAnd(b, 63)).toChar)
    case Expect2(acc) =>
      Expect1(bitwiseOr(bitwiseShl(acc, 6), bitwiseAnd(b, 63)))
    case Expect3(acc) =>
      Expect2(bitwiseOr(bitwiseShl(acc, 6), bitwiseAnd(b, 63)))
  }
}

def encodeChar(char: Char): (Byte, List[Byte]) = {
  val code = char.toInt
  if (code < 128) {
    (code.toByte, [])
  } else if (code < 2048) {
    (bitwiseOr(192, bitwiseShr(code, 6)).toByte,
    [bitwiseOr(128, bitwiseAnd(code, 63)).toByte])
  } else if (code < 65536) {
    (bitwiseOr(224, bitwiseShr(code, 12)).toByte,
    [bitwiseOr(128, bitwiseAnd(bitwiseShr(code, 6), 63)).toByte,
    bitwiseOr(128, bitwiseAnd(code, 63)).toByte])
  } else {
    (bitwiseOr(240, bitwiseShr(code, 18)).toByte,
    [bitwiseOr(128, bitwiseAnd(bitwiseShr(code, 12), 63)).toByte,
    bitwiseOr(128, bitwiseAnd(bitwiseShr(code, 6), 63)).toByte,
    bitwiseOr(128, bitwiseAnd(code, 63)).toByte])
  }
}

def decodeUTF8Reader[R] { reader: () => R / read[Char] }: R / read[Byte] = {
  try {
    reader()
  } with read[Char] { () =>
    resume {
      var state = Initial()
      untilDone {
        state = decodeChar(state, do read())
      }
    }
  }
}

def decodeUTF8Stream[R] { stream: () => R / emit[Byte] }: R / emit[Char] = {
  var state = Initial()
  try {
    stream()
  } with emit[Byte] { byte =>
    whenDone[Char] { char => do emit(char) } {
      state = decodeChar(state, byte)
    }
    resume(())
  }
}

def encodeUTF8Stream[R] { stream: () => R / emit[Char] }: R / emit[Byte] =
  try {
    stream()
  } with emit[Char] { char =>
    val (byte, rest) = encodeChar(char)
    do emit(byte)
    rest.each
    resume(())
  }

def encodeUTF8Reader[R] { reader: () => R / read[Byte] }: R / read[Char] = {
  var state = Nil()
  try {
    reader()
  } with read[Byte] { () =>
    resume {
      state match {
        case Nil() =>
          val (byte, rest) = encodeChar(do read())
          state = rest
          return byte
        case Cons(byte, rest) =>
          state = rest
          return byte
      }
    }
  }
}

def each(string: String): Unit / emit[Char] =
  decodeUTF8Stream { string.fromString.each }

def collectString[R] { stream: () => R / emit[Char] }: (R, String) = {
  val (result, bytes) = collectBytes { encodeUTF8Stream { stream } }
  (result, bytes.intoString)
}

def collectString { stream: () => Unit / emit[Char] }: String =
  collectString[Unit]{stream}.second




