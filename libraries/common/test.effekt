<<<<<<< HEAD
import string
import process
||||||| parent of e3e9b93b (Make the Effekt testing suite a little prettier)
import string
=======
import bench

interface Formatted {
  def supportsEscape(escape: String): Bool
}

namespace Formatted {
  def formatting[R] { prog : => R / Formatted }: R =
    try {
      prog()
    } with Formatted {
      def supportsEscape(escape: String) = resume(true)
    }

  def noFormatting[R] { prog : => R / Formatted }: R =
    try {
      prog()
    } with Formatted {
      def supportsEscape(escape: String) = resume(false)
    }

  def tryEmit(escape: String): String / Formatted =
    if (do supportsEscape(escape)) { escape } else { "" }
}

namespace Duration {
  def diff(fromNanos: Int, toNanos: Int) = toNanos - fromNanos
}

def red(s: String) = Formatted::tryEmit(ANSI::RED) ++ s ++ Formatted::tryEmit(ANSI::RESET)
def green(s: String) = Formatted::tryEmit(ANSI::GREEN) ++ s ++ Formatted::tryEmit(ANSI::RESET)
def dim(s: String) = Formatted::tryEmit(ANSI::FAINT) ++ s ++ Formatted::tryEmit(ANSI::RESET)
def bold(s: String) = Formatted::tryEmit(ANSI::BOLD) ++ s ++ Formatted::tryEmit(ANSI::RESET)
>>>>>>> e3e9b93b (Make the Effekt testing suite a little prettier)

interface Assertion {
  def assert(condition: Bool, msg: String): Unit
}

def assertTrue(condition: Bool, msg: String) =
  do assert(condition, msg)

def assertTrue(condition: Bool) =
  do assert(condition, "Assertion failed")

def assertFalse(condition: Bool, msg: String) =
  do assert(not(condition), msg)

def assertFalse(condition: Bool) =
  do assert(not(condition), "Assertion failed")

def assert(obtained: Int, expected: Int, msg: String): Unit / Assertion =
  assertEqual(obtained, expected, msg) { (x, y) => x == y }

def assert(obtained: Bool, expected: Bool, msg: String): Unit / Assertion =
  assertEqual(obtained, expected, msg) { (x, y) => x == y }

def assert(obtained: Char, expected: Char, msg: String): Unit / Assertion =
  assertEqual(obtained, expected, msg) { (x, y) => x == y }

def assert(obtained: String, expected: String, msg: String): Unit / Assertion =
  assertEqual(obtained, expected, msg) { (x, y) => x == y }

def assert(obtained: Int, expected: Int): Unit / { Assertion, Formatted } =
  assertEqual(obtained, expected) { (x, y) => x == y } { x => show(x) }

def assert(obtained: Bool, expected: Bool): Unit / { Assertion, Formatted } =
  assertEqual(obtained, expected) { (x, y) => x == y } { x => show(x) }

def assert(obtained: Char, expected: Char): Unit / { Assertion, Formatted } =
  assertEqual(obtained, expected) { (x, y) => x == y } { x => show(x) }

def assert(obtained: String, expected: String): Unit / { Assertion, Formatted } =
  assertEqual(obtained, expected) { (x, y) => x == y } { x => show(x) }

def assertEqual[A](obtained: A, expected: A, msg: String): Unit / Assertion =
  assertEqual(obtained, expected, msg) { (x, y) => x.equals(y) }

def assertEqual[A](obtained: A, expected: A): Unit / { Assertion, Formatted } =
  assertEqual(obtained, expected) { (x, y) => x.equals(y) } { x => x.genericShow }

def assertEqual[A](obtained: A, expected: A, msg: String) { equals: (A, A) => Bool }: Unit / Assertion =
  do assert(equals(obtained, expected), msg)

def assertEqual[A](obtained: A, expected: A) { equals: (A, A) => Bool } { show: A => String }: Unit / { Assertion, Formatted } =
  do assert(equals(obtained, expected), Formatted::tryEmit(ANSI::RESET) ++ "Expected: ".dim ++ show(expected).green ++ "\n  Obtained: ".dim ++ show(obtained).red)
  // NOTE:                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  //             Here's an accidental capture! Can we prevent this somehow nicely?

interface Test {
  def success(name: String, duration: Int): Unit
  def failure(name: String, msg: String, duration: Int): Unit
}

def test(name: String) { body: => Unit / Assertion } = {
  val startTime = bench::relativeTimestamp()
  try {
    body()
    val duration = Duration::diff(startTime, bench::relativeTimestamp())
    do success(name, duration)
  } with Assertion {
    def assert(condition, msg) =
      if (condition) resume(())
      else {
        val duration = Duration::diff(startTime, bench::relativeTimestamp())
        do failure(name, msg, duration)
      }
  }
}

/// Run a test suite with a given `name`.
/// If `printTimes` is `true` (or missing), prints out time in milliseconds.
/// Formats automatically using ANSI escapes.
def suite(name: String, printTimes: Bool) { body: => Unit / { Test, Formatted } }: Bool / {} = {
  with Formatted::formatting;

  def ms(duration: Int): String / Formatted =
    if (printTimes) {
      " " ++ ("[" ++ bench::formatMs(duration) ++ "]").dim
    } else {
      ""
    }

  println(name.bold)
  var failed = 0
  var passed = 0

  val totalDuration = timed {
    try { body() } with Test {
      def success(name, duration) = {
        passed = passed + 1
        println("✓".green ++ " " ++ name ++ duration.ms)
        resume(())
      }
      def failure(name, msg, duration) = {
        failed = failed + 1
        println("✕".red ++ " " ++ name ++ duration.ms)
        println("  " ++ msg.red)
        resume(())
      }
    }
  }

  def dimWhenZeroElse(s: String, n: Int) { colorIfNonZero: String => String / Formatted } =
    if (n == 0) { dim(s) }
    else { colorIfNonZero(s) }

  println("")
  println(" " ++ (passed.show ++ " pass").dimWhenZeroElse(passed) { green })
  println(" " ++ (failed.show ++ " fail").dimWhenZeroElse(failed) { red })
  println(" " ++ (passed + failed).show ++ " tests total" ++ totalDuration.ms)

  return failed == 0
}

/// Use as `def main() = mainSuite("...") { ... }`
def mainSuite(name: String) { body: => Unit / Test }: Unit = {
  val result = suite(name) { body() }
  val exitCode = if (result) 0 else 1
  exit(exitCode)
}

def suite(name: String) { body: => Unit / { Test, Formatted } }: Bool / {} =
  suite(name, true) { body }
