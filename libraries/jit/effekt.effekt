module effekt

// Side effection ops
// ==================
extern io def random(): Int = jit "random(): Int"
extern io def random(): Double = jit "random(): Double"

// Console ops
// ===========

extern io def println(s: String): Unit = jit "println(String): Unit"
extern io def printlnErr(s: String): Unit = jit "printlnErr(String): Unit"
extern io def readLn(): String = jit "readLn(): String"
extern io def readInt(): Int = jit "readInt(): Int"

def println(n: Int): Unit = println(show(n))
def println(n: Double): Unit = println(show(n))
def println(b: Bool): Unit = println(show(b))
def println(b: Unit): Unit = println("()")

// integer primitives
// ==================

extern pure def infixAdd(x: Int, y: Int): Int = jit "infixAdd(Int, Int): Int"
extern pure def infixMul(x: Int, y: Int): Int = jit "infixMul(Int, Int): Int"
extern pure def infixDiv(x: Int, y: Int): Int = jit "infixDiv(Int, Int): Int"
extern pure def infixSub(x: Int, y: Int): Int = jit "infixSub(Int, Int): Int"
extern pure def mod(x: Int, y: Int): Int = jit "mod(Int, Int): Int"
extern pure def abs(x: Int): Int = jit "abs(Int): Int"

// double primitives
// =================
extern pure def infixAdd(x: Double, y: Double): Double = jit "infixAdd(Double, Double): Double"
extern pure def infixMul(x: Double, y: Double): Double = jit "infixMul(Double, Double): Double"
extern pure def infixDiv(x: Double, y: Double): Double = jit "infixDiv(Double, Double): Double"
extern pure def infixSub(x: Double, y: Double): Double = jit "infixSub(Double, Double): Double"
extern pure def mod(x: Double, y: Double): Double = jit "mod(Double, Double): Double"
extern pure def abs(x: Double): Double = jit "abs(Double): Double"

extern pure def cos(x: Double): Double = jit "cos(Double): Double"
extern pure def acos(x: Double): Double = jit "acos(Double): Double"
extern pure def sin(x: Double): Double = jit "sin(Double): Double"
extern pure def asin(x: Double): Double = jit "asin(Double): Double"
extern pure def tan(x: Double): Double = jit "tan(Double): Double"
extern pure def atan(x: Double): Double = jit "atan(Double): Double"
extern pure def atan2(x: Double, y: Double): Double = jit "atan2(Double, Double): Double"

extern pure def cosh(x: Double): Double = jit "cosh(Double): Double"
extern pure def acosh(x: Double): Double = jit "acosh(Double): Double"
extern pure def sinh(x: Double): Double = jit "sinh(Double): Double"
extern pure def asinh(x: Double): Double = jit "asinh(Double): Double"
extern pure def tanh(x: Double): Double = jit "tanh(Double): Double"
extern pure def atanh(x: Double): Double = jit "atanh(Double): Double"

extern pure def sqrt(x: Double): Double = jit "sqrt(Double): Double"
extern pure def log(x: Double): Double = jit "log(Double): Double"
extern pure def log1p(x: Double): Double = jit "log1p(Double): Double"
extern pure def log10(x: Double): Double = jit "log10(Double): Double"
extern pure def exp(x: Double, y: Double): Double = jit "exp(Double, Double): Double"

extern pure def floor(x: Double): Double = jit "floor(Double): Double"
extern pure def ceil(x: Double): Double = jit "ceil(Double): Double"
extern pure def toInt(x: Double): Int = jit "toInt(Double): Int"
extern pure def toDouble(x: Int): Double = jit "toDouble(Int): Double"

// ordering on signed integers
// ===========================

extern pure def infixEq(x: Int, y: Int): Bool = jit "infixEq(Int, Int): Boolean"
extern pure def infixLt(x: Int, y: Int): Bool = jit "infixLt(Int, Int): Boolean"
extern pure def infixGt(x: Int, y: Int): Bool = jit "infixGt(Int, Int): Boolean"
def infixNeq(x: Int, y: Int): Bool = not(x == y)
def infixLte(x: Int, y: Int): Bool = (x == y) || (x < y)
def infixGte(x: Int, y: Int): Bool = (x == y) || (x > y)

def min(x: Int, y: Int): Int = {
  if (x < y) { x } else { y }
}
def max(x: Int, y: Int): Int = {
  if (x > y) { x } else { y }
}

// ordering on doubles
// ===================

extern pure def infixEq(x: Double, y: Double): Bool = jit "infixEq(Double, Double): Boolean"
extern pure def infixNeq(x: Double, y: Double): Bool = jit "infixNeq(Double, Double): Boolean"
extern pure def infixLt(x: Double, y: Double): Bool = jit "infixLt(Double, Double): Boolean"
extern pure def infixLte(x: Double, y: Double): Bool = jit "infixLte(Double, Double): Boolean"
extern pure def infixGt(x: Double, y: Double): Bool = jit "infixGt(Double, Double): Boolean"
extern pure def infixGte(x: Double, y: Double): Bool = jit "infixGte(Double, Double): Boolean"

// boolean algebra
// ===============

def infixEq(x: Bool, y: Bool): Bool = if (x) y else not(y)
def infixNeq(x: Bool, y: Bool): Bool = not(infixEq(x, y))
def not(b: Bool): Bool = if (b) false else true

def infixOr { first: => Bool } { second: => Bool }: Bool =
  if (first()) true else second()

def infixAnd { first: => Bool } { second: => Bool }: Bool =
  if (first()) second() else false

// operations on strings
// =====================
// TODO make safe
extern pure def infixConcat(s1: String, s2: String): String = jit "infixConcat(String, String): String"
extern pure def infixEq(s1: String, s2: String): Bool= jit "infixEq(String, String): Boolean"
extern pure def infixNeq(s1: String, s2: String): Bool= jit "infixEq(String, String): Boolean"
extern pure def show(value: Int): String = jit "show(Int): String"
extern pure def show(value: Double): String = jit "show(Double): String"
def show(value: Bool): String = if (value) "true" else "false"

// Benchmarking
// ============
extern io def currentTimeNanos(): Int = jit "currentTimeNanos(): Int"

// System
// ======
extern io def exit(code: Int): Nothing = jit "exit(Int): Void"
def panic(msg: String): Nothing = {
  printlnErr("Panic: " ++ msg);
  exit(1)
}

// Pairs
// =====
record Tuple2[A, B](first: A, second: B)
record Tuple3[A, B, C](first: A, second: B, third: C)
record Tuple4[A, B, C, D](first: A, second: B, third: C, fourth: D)
record Tuple5[A, B, C, D, E](first: A, second: B, third: C, fourth: D, fifth: E)
record Tuple6[A, B, C, D, E, F](first: A, second: B, third: C, fourth: D, fifth: E, sixth: F)

// Exceptions
// ==========
interface Exception[E] {
  def raise[A](exception: E, msg: String): A
}
record RuntimeError()

def raise[A](msg: String): A / Exception[RuntimeError] = do raise(RuntimeError(), msg)

// converts exceptions of (static) type E to an uncatchable panic that aborts the program
def panicOn[E] { prog: => Unit / Exception[E] }: Unit =
  try { prog() } with Exception[E] { def raise[A](exception: E, msg: String) = panic(msg) }

// reports exceptions of (static) type E to the console
def report[E] { prog: => Unit / Exception[E] }: Unit =
  try { prog() } with Exception[E] { def raise[A](exception: E, msg: String) = println(msg) }

// ignores exceptions of (static) type E
// TODO this should be called "ignore" but that name currently clashes with internal pattern matching names on $effekt
def ignoring[E] { prog: => Unit / Exception[E] }: Unit =
  try { prog() } with Exception[E] { def raise[A](exception: E, msg: String) = () }

// Control Flow
// ============
def each(start: Int, end: Int) { action: (Int) => Unit } = {
  var i = start;
  while (i < end) {
      action(i)
      i = i + 1
  }
}

def repeat(n: Int) { action: () => Unit } = each(0, n) { n => action() }


// For boxing polymorphic values
record BoxedUnit(unboxUnit: Unit)
record BoxedBool(unboxBoolean: Bool)
record BoxedInt(unboxInt: Int)
record BoxedDouble(unboxDouble: Double)
record BoxedString(unboxString: String)
