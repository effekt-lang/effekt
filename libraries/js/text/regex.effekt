module text/regex

import string
import option
import list


extern type Regex

// matches and groups
record Range(start: Int, end: Int)
record Group(matched: String, index: Option[Range])
record Match(matched: String, start: Int, end: Int, groups: List[Group])

/**
 * Specifies flags that modify regular expression behavior.
 *
 * Flags:
 * - Global: Matches all occurrences in the input string.
 * - IgnoreCase: Performs case-insensitive matching.
 * - Multiline: Treats ^ and $ as start/end of each line.
 * - GenerateIndices: Enables capture group index retrieval.
 *
 * Usage:
 * ```effekt
 * val regex = regex("pattern", [Global(), IgnoreCase(), GenerateIndices()])
 * ```
 *
 * Note: GenerateIndices is required for capture group indexing.
 * Without it, capture group indices will be None.
 */
type RegexFlags {
  Global();
  IgnoreCase();
  Multiline();
  GenerateIndices();
}

/**
 * Constructs a Regex object from a pattern string.
 *
 * This function creates a Regex object with no flags set.
 *
 * @param pattern The regular expression pattern as a string.
 * @return A Regex object that can be used with the `exec` function.
 *
 * Note: To extract substring indices for capturing groups, the `GenerateIndices` flag
 * must be explicitly set using the overloaded `regex(pattern: String, flags: List[RegexFlags])` function.
 * Without this flag, indices of capture groups will always be `None`.
 *
 * Example usage:
 * ```effekt
 * val simpleRegex = regex("\\w+")
 * val math = exec(simpleRegex, "Hello World")
 * ```
 *
 * For more control over flags, use the overloaded version:
 * ```effekt
 * val regexWithIndices = regex("(\\w+)", [Global(), GenerateIndices()])
 * ```
 */
def regex(pattern: String): Regex = regex(pattern, [])


/**
 * Constructs a Regex object from a pattern string and optional flags.
 *
 * @param pattern The regular expression pattern as a string.
 * @param flags A List of RegexFlags containing any combination of the following flags:
 *   - `Global` Global search (find all matches rather than stopping after the first match).
*       This flags makes the regex object stateful and `exec` will return the next match on each call.
 *   - `IgnoreCase` Case-insensitive search
 *   - `Multiline Multi-line search (^ and $ match start/end of each line)
 *   - `GenerateIndices Generate indices for substring matches
 *
 * @return A Regex object that can be used with the `exec` function.
 *
 * Example usage:
 * ```effekt
 * val simpleRegex = regex("\\w+")
 * val complexRegex = regex("(\\w+)\\s(\\d+)", [Global(), GenerateIndices()]))
 * ```
 *
 * Note: The `GenerateIndices` flag is required for extracting substring indices of groups.
 * If not present, the indices of capture groups will always be `None`.
 */
def regex(pattern: String, flags: List[RegexFlags]): Regex = {
  val flags = flags.map{it => it.show()}.join("")
  internal::unsafeRegex(pattern, flags)
}

/**
 * Executes the regex against the given string.
 *
 * @param reg The Regex object to execute.
 * @param str The string to match against.
 * @return Option[Match] A Some(Match) if a match is found, None otherwise.
 *
 * The returned Match object contains:
 * - matched: The full matched string.
 * - start: The starting index of the match.
 * - end: The ending index of the match if `Global` flag is set, otherwise 0
 * - groups: A list of Group objects for each capturing group.
 *
 * Each Group object contains:
 * - matched: The matched substring for this group.
 * - index: An Option[Range] with start and end indices if the 'd' flag is set, None otherwise.
 *
 * Note: This function is stateful when the global flag 'g' is set on the Regex object.
 * Subsequent calls with the same Regex and string will return the next match in the string.
 *
 * Example usage:
 * ```effekt
 * val rx = regex("(\\w+)\\s(\\d+)", "g")
 * val text = "Hello 123 World 456"
 * while (true) {
 *  exec(rx, text) match = {
 *    Some(m) =>
 *      println("matched: " ++ m.matched ++ "range: " ++ m.start.show() ++ ", " ++ m.end.show()))
 *    None() => break
 * }
 * ```
 */
def exec(reg: Regex, str: String): Option[Match] = {
  def toGroup(g: GroupMatch): Group = Group(
    matched(g),
    zip(undefinedToOption(start(g)), undefinedToOption(end(g))) { (s, e) => Range(s, e)}
  )

  val regexMatch = internal::unsafeExec(reg, str).undefinedToOption()
  regexMatch.map { it =>
    val fullMatch = fullMatch(it)
    Match(
      fullMatch.matched,
      fullMatch.start,
      fullMatch.end,
      subGroups(it).toList().map{toGroup}
    )
  }
}

// internal representation
extern type GroupMatch
extern pure def matched(g: GroupMatch): String = js "${g}.matched"
extern pure def start(g: GroupMatch): Int = js "${g}.start"
extern pure def end(g: GroupMatch): Int = js "${g}.end"

extern type RegexMatch
extern pure def fullMatch(r: RegexMatch): GroupMatch = js "${r}.fullMatch"
extern pure def subGroups(r: RegexMatch): Array[GroupMatch] = js "${r}.groups"

extern js """
function regex$exec(reg, str) {
  const match = reg.exec(str);
  if (match === null)  return undefined

  const fullMatch = { matched: match[0], start: match.index, end: reg.lastIndex };
  var groups = [];
  for (var i = 1; i < match.length; i++) {
    if (match[i] !== undefined) {
      if (match.indices !== undefined && match.indices[i] !== undefined) {
        groups.push({
          matched: match[i],
          start: match.indices[i][0],
          end: match.indices[i][1]
        });
      } else {
        groups.push({
          matched: match[i],
        });
      }
    } else {
      // Push an empty string if an intermediate group is undefined
      groups.push({matched: ""});}
  }

  return { fullMatch: fullMatch, groups: groups };
}

"""

// internal calls
namespace internal {
  extern io def unsafeExec(reg: Regex, str: String): RegexMatch = js "regex$exec(${reg}, ${str})"

  extern pure def unsafeRegex(str: String, flags: String): Regex = js "new RegExp(${str}, ${flags})"
}


// Show
def show(m: Match): String = {
  val start = m.start.show()
  val end = m.end.show()
  val groups = m.groups.map{it => it.show()}.join("\n")

  [
    "matched: " ++ m.matched,
    "from: (" ++ start ++ ", " ++ end ++ ")",
    "Groups:",
    groups
  ].join("\n")
}

def show(g: Group): String = {
  val range = g.index.show{ it => show(it) }

  g.matched ++  "\nfrom: " ++ range
}

def show(r: Range): String = {
  "(" ++ r.start.show() ++ ", " ++ r.end.show() ++ ")"
}

def show(f: RegexFlags): String = {
  f match {
    case Global() => "g"
    case IgnoreCase() => "i"
    case Multiline() => "m"
    case GenerateIndices() => "d"
  }
}
