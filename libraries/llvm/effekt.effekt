module effekt

extern include "rts.ll"
extern include "primitives.ll"


// i/o

extern effect Console

extern io def println(n: Int): Unit / Console =
  "%unit = call %Pos @c_println_Int(%Int %n)   ret %Pos %unit"

extern io def println(b: Boolean): Unit / Console =
  "%unit = call %Pos @c_println_Boolean(%Pos %b)   ret %Pos %unit"

extern io def println(x: Double): Unit / Console =
  "%unit = call %Pos @c_println_Double(%Double %x)   ret %Pos %unit"


// integer arithmetic

extern pure def infixAdd(x: Int, y: Int): Int =
  "%z = call %Int @c_add_Int_Int(%Int %x, %Int %y)   ret %Int %z"

extern pure def infixSub(x: Int, y: Int): Int =
  "%z = call %Int @c_sub_Int_Int(%Int %x, %Int %y)   ret %Int %z"

extern pure def infixMul(x: Int, y: Int): Int =
  "%z = call %Int @c_mul_Int_Int(%Int %x, %Int %y)   ret %Int %z"

extern pure def infixDiv(x: Int, y: Int): Int =
  "%z = call %Int @c_div_Int_Int(%Int %x, %Int %y)   ret %Int %z"

extern pure def mod(x: Int, y: Int): Int =
  "%z = call %Int @c_mod_Int_Int(%Int %x, %Int %y)   ret %Int %z"


// floating-point arithmetic

extern pure def infixAdd(x: Double, y: Double): Double =
  "%z = call %Double @c_add_Double_Double(%Double %x, %Double %y)   ret %Double %z"

extern pure def infixSub(x: Double, y: Double): Double =
  "%z = call %Double @c_sub_Double_Double(%Double %x, %Double %y)   ret %Double %z"

extern pure def infixMul(x: Double, y: Double): Double =
  "%z = call %Double @c_mul_Double_Double(%Double %x, %Double %y)   ret %Double %z"

extern pure def infixDiv(x: Double, y: Double): Double =
  "%z = call %Double @c_div_Double_Double(%Double %x, %Double %y)   ret %Double %z"

extern pure def mod(x: Double, y: Double): Double =
  "%z = call %Double @c_mod_Double_Double(%Double %x, %Double %y)   ret %Double %z"


// ordering on signed integers
// ===========================

extern pure def infixEq(x: Int, y: Int): Boolean =
  "%z = icmp eq %Int %x, %y   %fat_z = zext i1 %z to i64   %adt_boolean = insertvalue %Pos zeroinitializer, i64 %fat_z, 0   ret %Pos %adt_boolean"

extern pure def infixNeq(x: Int, y: Int): Boolean =
  "%z = icmp ne %Int %x, %y   %fat_z = zext i1 %z to i64   %adt_boolean = insertvalue %Pos zeroinitializer, i64 %fat_z, 0   ret %Pos %adt_boolean"

extern pure def infixLt(x: Int, y: Int): Boolean =
  // TODO is the following more correct? "%z = icmp slt %Int %x, %y %w = zext i1 %z to i64 %b = insertvalue %Pos zeroinitializer, i64 %w, 0 ret %Pos %b"
  "%z = icmp slt %Int %x, %y   %fat_z = zext i1 %z to i64   %adt_boolean = insertvalue %Pos zeroinitializer, i64 %fat_z, 0   ret %Pos %adt_boolean"

extern pure def infixLte(x: Int, y: Int): Boolean =
  "%z = icmp sle %Int %x, %y   %fat_z = zext i1 %z to i64   %adt_boolean = insertvalue %Pos zeroinitializer, i64 %fat_z, 0   ret %Pos %adt_boolean"

extern pure def infixGt(x: Int, y: Int): Boolean =
  "%z = icmp sgt %Int %x, %y   %fat_z = zext i1 %z to i64   %adt_boolean = insertvalue %Pos zeroinitializer, i64 %fat_z, 0   ret %Pos %adt_boolean"

extern pure def infixGte(x: Int, y: Int): Boolean =
  "%z = icmp sge %Int %x, %y   %fat_z = zext i1 %z to i64   %adt_boolean = insertvalue %Pos zeroinitializer, i64 %fat_z, 0   ret %Pos %adt_boolean"


// boolean algebra
// ===============

extern pure def infixEq(x: Boolean, y: Boolean): Boolean =
  "%slim_x = extractvalue %Pos %x, 0   %slim_y = extractvalue %Pos %y, 0   %slim_z = icmp eq i64 %slim_x, %slim_y   %fat_z = zext i1 %slim_z to i64   %adt_boolean = insertvalue %Pos zeroinitializer, i64 %fat_z, 0   ret %Pos %adt_boolean"

extern pure def infixNeq(x: Boolean, y: Boolean): Boolean =
  "%slim_x = extractvalue %Pos %x, 0   %slim_y = extractvalue %Pos %y, 0   %slim_z = icmp ne i64 %slim_x, %slim_y   %fat_z = zext i1 %slim_z to i64   %adt_boolean = insertvalue %Pos zeroinitializer, i64 %fat_z, 0   ret %Pos %adt_boolean"

extern pure def not(adt_p: Boolean): Boolean =
  "%p = extractvalue %Pos %adt_p, 0   %q = xor i64 1, %p   %adt_q = insertvalue %Pos zeroinitializer, i64 %q, 0   ret %Pos %adt_q"

extern pure def infixOr(adt_p: Boolean, adt_q: Boolean): Boolean =
  "%p = extractvalue %Pos %adt_p, 0   %q = extractvalue %Pos %adt_q, 0   %r = or i64 %p, %q   %adt_r = insertvalue %Pos zeroinitializer, i64 %r, 0   ret %Pos %adt_r"

extern pure def infixAnd(adt_p: Boolean, adt_q: Boolean): Boolean =
  "%p = extractvalue %Pos %adt_p, 0   %q = extractvalue %Pos %adt_q, 0   %r = and i64 %p, %q   %adt_r = insertvalue %Pos zeroinitializer, i64 %r, 0   ret %Pos %adt_r"
