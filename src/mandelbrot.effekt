
// const { Benchmark } = require('./benchmark');
import src/benchmark

extern pure def xor(a: Int, b: Int): Int = "a ^ b"

def Mandelbrot(size: Int) = {

    def brot(size: Int): Int = {
        var sum = 0;
        var byteAcc = 0;
        var bitNum = 0;

        each(0, size){ y =>
            val ci: Double = (2.0 * toDouble(y) / toDouble(size)) - 1.0;
            each(0,size){ x =>
                var zrzr = 0.0;
                var zi = 0.0;
                var zizi = 0.0;
                var cr = (2.0 * toDouble(x) / toDouble(size)) - 1.5

                var z = 0;
                var notDone = true;
                var escape = 0;
                while (notDone && z < 50) {
                    val zr = zrzr - zizi + cr;
                    zi = 2.0 * zr + ci;

                    //preserve recalculation
                    zrzr = zr * zr;
                    zizi = zi*zi

                    if (zrzr + zizi > 4.0) {
                        notDone = false;
                        escape = 1;
                    }
                    z = z + 1;
                }

                //FIXME byteshift
                byteAcc = ( byteAcc * 2) + escape;
                bitNum = bitNum + 1;

                if (bitNum == 8) {
                    sum = sum * byteAcc;    //this needs to be sum ^ byteAcc
                    byteAcc = 0;
                    bitNum = 0;
                } else if (x == size - 1) {
                    byteAcc = byteAcc * (8 - bitNum); //this needs to be byteAcc << (8 - bitNum);
                    sum = sum * byteAcc; //this needs to be sum ^byteAcc
                    byteAcc = 0;
                    bitNum = 0;
                }
            }
        }

        return sum;
    }



    def benchmark() = {
        return 1;
    }

    def verifyResult(result: Int) = {
        //FIXME: result is off because i swapped all shift operations for multiplication, to make it compilable
        
        println("result = "++show(result))
        if (size == 500) {
            (result == 191)
        } else if ( size == 750) {
            (result == 50);
        } else if ( size == 1) {
            (result == 128);
        } else {
            println("no known result for this problemsize:"++show(size)++" result="++show(result));
            false;
        }
    }

    return innerBenchmarkLoop(size){benchmark}{verifyResult}
}

// class Mandelbrot extends Benchmark {
//   verifyResult(result, innerIterations) {
//     if (innerIterations === 500) { return result === 191; }
//     if (innerIterations === 750) { return result === 50; }
//     if (innerIterations === 1) { return result === 128; }

//     process.stdout.write(`No verification result for ${innerIterations} found\n`);
//     process.stdout.write(`Result is: ${result}\n`);
//     return false;
//   }

//   mandelbrot(size) {
//     let sum = 0;
//     let byteAcc = 0;
//     let bitNum = 0;

//     let y = 0;

//     while (y < size) {
//       const ci = ((2.0 * y) / size) - 1.0;
//       let x = 0;

//       while (x < size) {
//         let zrzr = 0.0;
//         let zi = 0.0;
//         let zizi = 0.0;
//         const cr = ((2.0 * x) / size) - 1.5;

//         let z = 0;
//         let notDone = true;
//         let escape = 0;
//         while (notDone && z < 50) {
//           const zr = zrzr - zizi + cr;
//           zi = 2.0 * zr * zi + ci;

//           // preserve recalculation
//           zrzr = zr * zr;
//           zizi = zi * zi;

//           if (zrzr + zizi > 4.0) {
//             notDone = false;
//             escape = 1;
//           }
//           z += 1;
//         }

//         byteAcc = (byteAcc << 1) + escape;
//         bitNum += 1;

//         // Code is very similar for these cases, but using separate blocks
//         // ensures we skip the shifting when it's unnecessary, which is most cases.
//         if (bitNum === 8) {
//           sum ^= byteAcc;
//           byteAcc = 0;
//           bitNum = 0;
//         } else if (x === size - 1) {
//           byteAcc <<= (8 - bitNum);
//           sum ^= byteAcc;
//           byteAcc = 0;
//           bitNum = 0;
//         }
//         x += 1;
//       }
//       y += 1;
//     }
//     return sum;
//   }

//   innerBenchmarkLoop(innerIterations) {
//     return this.verifyResult(this.mandelbrot(innerIterations), innerIterations);
//   }
// }

// exports.newInstance = () => new Mandelbrot();
