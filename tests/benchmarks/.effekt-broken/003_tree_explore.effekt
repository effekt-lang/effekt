// Jonathan Frech, 2022-08-25
// adapted from: https://raw.githubusercontent.com/effect-handlers/effect-handlers-bench/a61925f19c60600cd0bdaf8b3a6b82eea9aefcf0/benchmarks/koka/003_tree_explore/benchmark.kk


import immutable/list


// missing Effekt stdlib features

def abs(n: Int): Int = if (n < 0) 0 - n else n

def max(n: Int, m: Int): Int = if (n > m) n else m


// manually transpiled koka

effect Choose {
    def choose(): Boolean
}

type Tree[A] {
    Leaf();
    Node(left: Tree[A], v: A, right: Tree[A])
}

def operator(x: Int, y: Int): Int =
    mod(abs(x - (503 * y) + 37), 1009)

def makeTree(n: Int): Tree[Int] = {
    if (n == 0) {
        Leaf()
    } else {
        val sub = makeTree(n-1)
        Node(sub, n, sub)
    }
}

def maxL(l: List[Int]): Int = l match {
    case Nil() => -1 // -inf
    case Cons(x, Nil()) => x
    case Cons(x, xs) => max(x, maxL(xs))
}

def sumPaths(tree: Tree[Int]): Int = {
    var state = 0
    def explore(tr: Tree[Int]): Int / Choose = tr match {
        case Leaf() => state
        case Node(left, v, right) =>
            val next = if (do choose()) left else right
            state = operator(state, v)
            operator(v, explore(next))
    }

    def chooseHandler(): List[Int] = {
        try {
            Cons(explore(tree), Nil())
        } with Choose {
            def choose() = append(resume(true), resume(false))
        }
    }

    def iterate(n: Int): Int = {
        if (n == 0) {
            state
        } else {
            state = maxL(chooseHandler())
            iterate(n-1)
        }
    }
    iterate(10)
}


// deviating invocation

def main() = println(sumPaths(makeTree(4))) // `16` is too large for the JS backend
